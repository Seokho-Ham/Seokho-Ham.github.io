I"<h2 id="jvm이란">JVM이란?</h2>

<p>JVM은 자바 가상 머신(Java Virtual Machine)으로 자바 프로그램을 동작시키는 역할을 한다. 정확하게는 자바의 바이트코드를 읽고 해석하고 실행하는 역할이다.</p>

<!--more-->

<h3 id="jvm이-왜-필요할까">JVM이 왜 필요할까?</h3>

<p>개발자가 작성한 소스코드는 컴퓨터가 이해할 수 있는 바이트코드로 변환이 필요하다. 하지만 OS 별로 이해하고 실행시킬 수 있는 코드가 다르기 때문에 OS 별로 다르게 컴파일 해야한다.
JVM을 통해 이런 문제를 해결할 수 있는데, Java는 OS에 상관없이 JVM를 기반으로 동작하도록 설계되었기 때문에 동일한 코드를 가지고 실행할 수 있다.<br />
(JVM은 OS에 맞는 버전으로 설치해야한다.)</p>

<p><br /></p>

<h2 id="jvm의-특징">JVM의 특징</h2>

<ol>
  <li>스택 기반으로 동작한다.</li>
  <li>모든 참조형 타입을 심볼릭 레퍼런스를 통해 참조한다.
    <ul>
      <li>실제 메모리 주소가 아닌, 참조하는 대상의 이름을 지칭하는 것.</li>
      <li>런타임 시 심볼릭 레퍼런스를 실제 메모리 주소로 링킹한다.</li>
    </ul>
  </li>
  <li>가비지 컬렉션이 사용하지 않는 데이터를 제거해줌으로써 메모리 관리를 해준다. 즉, 사용자가 메모리 관리에 거의 신경쓰지 않아도 된다.</li>
  <li>기본 자료형을 명확하게 정의해서(플랫폼에 따라 타입의 크기가 변하지 않는다) 호환성이 유지되고, 독립성을 보장한다.</li>
  <li>네트워크 바이트 오더 (<em>정확히 이해를 못했다</em>)</li>
</ol>

<p><br /></p>

<h2 id="자바-프로그램-동작-과정">자바 프로그램 동작 과정</h2>

<blockquote>
  <ol>
    <li>.java 파일을 .class 파일로 컴파일 한다.<br />
(소스코드 -&gt; 자바 바이트코드로 변환하는 과정)</li>
    <li>JVM의 클래스 로더가 바이트코드를 읽어온다.</li>
    <li>코드가 런타임 데이터 영역에 로딩된다.</li>
    <li>실행 엔진이 바이트코드를 실행한다.</li>
  </ol>
</blockquote>

<p><img src="/images/JVM-Model.jpg" width="800" height="600" /></p>

<p><br /></p>

<h2 id="jvm-구조">JVM 구조</h2>

<h5 id="1-클래스-로더class-loader">1. 클래스 로더(Class Loader)</h5>

<p>자바는 런타임 시점에 클래스를 로드한다. 이 로드하는 역할을 하는 것이 클래스 로더다.<br />
jar 파일 내에 저장된 클래스들을 런타임 데이터 영역에 배치한다.</p>

<p><br /></p>

<h5 id="2-실행-엔진execution-engine">2. 실행 엔진(Execution Engine)</h5>

<p>런타임 데이터 영역에 배치된 바이트 코드를 실행하는 역할을 한다. 명령어 단위로 읽고 실행한다.<br />
자바 바이트코드는 기계가 완전히 이해할 수 있는 코드는 아니다. 즉, 완전한 기계어로 변환이 필요한데 실행엔진이 이것을 담당한다.</p>

<p>2가지 방식을 사용하는데 아래와 같다.</p>

<p><strong>1. 인터프리터</strong></p>

<ul>
  <li>명령어 단위로 읽어서 실행하는 방식이다. 한줄씩 수행하기 때문에 느리다.</li>
  <li>한번만 수행되는 코드는 인터프리터 방식으로 하는것이 효율적이다.</li>
</ul>

<p><strong>2. JIT 컴파일러</strong></p>

<ul>
  <li>인터프리터 방식을 사용하다가 적절한 시점에 바이트코드 전체를 컴파일하여 기계어로 변환하고 전체를 실행하는 방식이다.</li>
  <li>속도가 훨씬 빠르며, 변환된 기계어는 캐시에 보관되어 재사용 시 더이상 컴파일이 필요하지 않다.</li>
</ul>

<p>메서드의 사용 빈도수를 기준으로 컴파일 방식이 정해진다.</p>

<p><br /></p>

<h5 id="3-런타임-데이터-영역runtime-data-area">3. 런타임 데이터 영역(Runtime Data Area)</h5>

<p>프로그램을 수행하기 위해서 OS로부터 할당받은 메모리 공간을 의미한다. 공통으로 사용하는 공간은 3가지영역이 있으며, 나머지 3가지 영역은 각 스레드별로 생성된다.</p>

<h6 id="공통-영역">공통 영역</h6>

<p><strong>1. 힙 영역</strong></p>

<ul>
  <li>인스턴스를 저장하는 영역이다.</li>
</ul>

<p><strong>2. 메서드 영역</strong></p>

<ul>
  <li>JVM이 시작될 때 생성된다.</li>
  <li>클래스로더로 읽어온 클래스와 인터페이스의 정보를 가지고 있는 영역이다.</li>
  <li>런타임 상수 풀도 이곳에 포함되어 있다</li>
</ul>

<p><strong>3. 런타임 상수 풀</strong></p>

<ul>
  <li>클래스와 인터페이스의 상수뿐만 아니라, 메서드와 필드에 대한 모든 레퍼런스까지 담고 있는 테이블이다.</li>
  <li>JVM은 런타임 상수 풀을 통해 사용할 메서드나 필드의 실제 주소를 찾아서 참조한다.</li>
</ul>

<p><br /></p>

<h6 id="스레드-별-영역">스레드 별 영역</h6>

<p><strong>1. PC 레지스터</strong></p>

<ul>
  <li>스레드가 시작될 때 생성된다. 어떤 부분을 어떤 명령으로 실행할것인지에 대한 기록을 하는 영역이다.</li>
  <li>현재 수행중인 JVM 명령의 주소를 갖는다.</li>
</ul>

<p><strong>2. JVM 스택</strong></p>

<ul>
  <li>임시로 할당되었다가 메소드가 끝나면 소멸되는 데이터를 저장하는 영역이다. 로컬 변수등을 저장하고 있는다.</li>
  <li><strong>스택 프레임</strong>
    <ul>
      <li>하나의 메서드가 실행될 때마다 생성되며, 해당 스레드에 있는 JVM 추가된다. 종료되면 제거된다.</li>
      <li>해당 메서드에서 사용되는 지역변수 배열, 실제 메서드의 작업공간인 피연산자 스택이 존재한다.</li>
    </ul>
  </li>
</ul>

<p><strong>3. 네이티브 메서드 스택</strong></p>

<ul>
  <li>바이트코드가 아닌 실제 실행할 수 있는 기계어로 작성된 프로그램을 실행시키는 영역이다.</li>
  <li>다른 언어로 작성된 코드를 위한 공간이다.</li>
</ul>

<p><br /></p>

<h3 id="참고-자료">참고 자료</h3>

<ul>
  <li><a href="https://d2.naver.com/helloworld/1230">NaverD2 - JVM Internal</a></li>
  <li><a href="https://steady-coding.tistory.com/305">Jbee님의 블로그 - JVM 메모리 구조란?</a></li>
</ul>
:ET