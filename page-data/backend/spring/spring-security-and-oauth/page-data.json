{"componentChunkName":"component---src-templates-blog-template-js","path":"/backend/spring/spring-security-and-oauth/","result":{"data":{"cur":{"id":"766cc513-3622-5387-a92f-5c9383ec5794","html":"<h2 id=\"서론\" style=\"position:relative;\"><a href=\"#%EC%84%9C%EB%A1%A0\" aria-label=\"서론 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>서론</h2>\n<p>저는 이전에 참여했던 사이드 프로젝트 에서 OAuth 로그인 개발을 담당했습니다.<br>\n그리고 이번에 프로젝트 리팩토링을 계획하면서 가장 마음에 안들던 로그인 관련 코드를 개선하기로 결정했습니다.</p>\n<p>최초 기획에서는 카카오 로그인만을 사용하기로 했기 때문에 카카오 로그인에 맞게 코드를 작성하였고, 현재 로그인 관련 코드는 카카오 로그인에 종속적인 코드입니다. 때문에 새로운 로그인 방식을 도입하기에도 까다로운 상황이라 이번 기회에 OAuth 로그인 관련 코드를 개선하기로 했습니다.</p>\n<p>OAuth 관련 클래스들을 추상화하기 위해 고민하던 중 SpringSecurity에서는 어떻게 여러개의 플랫폼에 쉽게 대응할 수 있도록 했는지, 실제 내부 동작은 어떻게 동작하는지 궁금해졌고 그래서 디버깅을 통해 내부 동작을 학습해보았습니다.</p>\n<hr>\n<h2 id=\"springsecurity\" style=\"position:relative;\"><a href=\"#springsecurity\" aria-label=\"springsecurity permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>SpringSecurity?</h2>\n<p>공식문서에서는 애플리케이션 보안(특히 유저의 인증, 인가)을 관리하기 위해 제공되는 프레임워크라고 설명합니다.\n대표적인 특징으로는 Spring의 Filter를 이용해서 처리한다는 점이 있습니다.<br>\n(더 자세한 설명은 <a href=\"https://docs.spring.io/spring-security/site/docs/3.2.10.RELEASE/reference/htmlsingle/html5/#what-is-acegi-security\"><strong>공식문서</strong></a>를 읽어보시면 될거 같습니다.)</p>\n<p>SpringSecurity에 대한 소개가 주제가 아니기 때문에 해당 글을 읽을때 필수적으로 필요한 개념들만 간단하게 정리하고 넘어가겠습니다.</p>\n<ul>\n<li><strong>SecurityContextHolder</strong>\n<ul>\n<li>SpringSecurity에서는 기본적으로 유저의 정보를 ThreadLocal을 SecurityContext를 생성해 관리합니다. 해당 Context를 관리할 수 있는 클래스입니다.</li>\n<li>Context의 생성부터 소멸을 관리합니다.</li>\n</ul>\n</li>\n<li><strong>SecurityContext</strong>\n<ul>\n<li>쓰레드별로 생성되는 클래스이며, 실제 요청 유저와 관련된 정보가 담기는 Authentication 객체가 저장되는 공간입니다.</li>\n<li>요청이 끝날때 해당 Context 객체는 사라집니다.</li>\n</ul>\n</li>\n<li><strong>Authentication</strong>\n<ul>\n<li>현재 요청을 보낸 유저의 실제 정보를 담고 있는 객체를 의미합니다.</li>\n<li>유저의 롤, 인증된 플랫폼 명, 유저 정보 등을 담고 있습니다.</li>\n</ul>\n</li>\n<li><strong>AuthenticationProvider(AuthenticationManager)</strong>\n<ul>\n<li>요청 정보를 가지고 리소스 서버에 요청을 보내 유저 인증을 처리하는 클래스입니다.</li>\n<li>AuthenticationManager와 동일한 클래스는 아니지만 Manger내부의 Provider가 실제 인증을 처리하기 때문에 여기서는 묶어서 작성했습니다.</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"springsecurity는-어떻게-여러-플랫폼에-대해-유연하게-처리하는가\" style=\"position:relative;\"><a href=\"#springsecurity%EB%8A%94-%EC%96%B4%EB%96%BB%EA%B2%8C-%EC%97%AC%EB%9F%AC-%ED%94%8C%EB%9E%AB%ED%8F%BC%EC%97%90-%EB%8C%80%ED%95%B4-%EC%9C%A0%EC%97%B0%ED%95%98%EA%B2%8C-%EC%B2%98%EB%A6%AC%ED%95%98%EB%8A%94%EA%B0%80\" aria-label=\"springsecurity는 어떻게 여러 플랫폼에 대해 유연하게 처리하는가 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>SpringSecurity는 어떻게 여러 플랫폼에 대해 유연하게 처리하는가?</h2>\n<p>제가 리팩토링에 앞서 가장 고민하던 부분은 각 플랫폼별로 요청 형태와 응답 형태가 조금씩 다른데 이걸 어떻게 깔끔하게 처리할것인가였습니다.<br>\nSpringSecurity에서는 다음과 같은 방식으로 각각 처리했습니다.</p>\n<p><strong>[요청]</strong>\nSpringSecurity에서는 각각의 리소스 서버에 대한 정보(clientId, clientSecret, 각 api uri 등등)를 ClientRegistration이라는 클래스로 관리합니다.</p>\n<p><strong>1. 각각의 플랫폼에 대한 정보를 ClientRegistration 타입의 객체로 생성합니다.</strong></p>\n<p><img src=\"https://github.com/Seokho-Ham/seokho-ham.github.io/assets/57708971/9e5d48f9-047c-44b3-b38f-c3a5ec7cdf72\" width=\"600px\"><br/></p>\n<p><strong>2. 모든 ClientRegistration 객체들을 InMemoryClientRegistrationRepository 타입의 Bean에서 Map 형태로 관리합니다.</strong></p>\n<p><img src=\"https://github.com/Seokho-Ham/seokho-ham.github.io/assets/57708971/ee2456b1-7f08-43c1-89c0-78d46379f074\" width=\"600px\"><br/></p>\n<p><strong>3. 유저의 요청이 올때 해당 Repository에서 플랫폼명에 맞는 ClientRegistration 정보를 사용해 인증요청들을 처리합니다.</strong></p>\n<p><strong>[응답]</strong></p>\n<p>응답의 경우 객체의 필드에 값을 매핑을하고 있던 저의 방식과 다르게 추상화 된 User객체를 만들고 실제 데이터들은 Map형태로 저장하고 있습니다. 아래 코드에서 보이는 attributes라는 Map형태의 필드에 응답값들을 저장합니다.</p>\n<p><img src=\"https://github.com/Seokho-Ham/seokho-ham.github.io/assets/57708971/d11efeea-c7a6-4504-b658-7f675680af1e\" width=\"600px\"><br/></p>\n<p>그리고 각 요청에서 실제 필요한 값을 Dto에 매핑하는 작업은 개발자에게 위임하고 있습니다.<br>\n엄청 특별한 방법은 아니지만 이 코드를 보며 추상화를 어떻게 해야할지 감을 잡을 수 있었습니다.</p>\n<hr>\n<h2 id=\"springsecurity가-oauth로그인을-처리하는-과정\" style=\"position:relative;\"><a href=\"#springsecurity%EA%B0%80-oauth%EB%A1%9C%EA%B7%B8%EC%9D%B8%EC%9D%84-%EC%B2%98%EB%A6%AC%ED%95%98%EB%8A%94-%EA%B3%BC%EC%A0%95\" aria-label=\"springsecurity가 oauth로그인을 처리하는 과정 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>SpringSecurity가 OAuth로그인을 처리하는 과정</h2>\n<p>다음은 SpringSecurity가 OAuth 로그인을 처리하는 Flow입니다.<br>\n이해를 돕고자 흐름도를 그렸습니다.</p>\n<p><img src=\"https://github.com/Seokho-Ham/seokho-ham.github.io/assets/57708971/86c7fba8-e51b-4506-9d81-67101b470739\" width=\"600px\"><br/></p>\n<p><strong>첫번째 그림은 유저가 처음 로그인 요청을 했을 때의 Flow입니다.</strong><br>\n<strong>[1~2]</strong> 유저가 우리의 서버에 로그인 요청을 보내면 서버에서는 리소스 서버로 redirect를 시킵니다.</p>\n<ul>\n<li>이때 위에서 설명드린 InMemoryClientRegistrationRepository에서 ClientRegistration 객체를 찾아 정보를 얻어옵니다.</li>\n</ul>\n<p><img src=\"https://github.com/Seokho-Ham/seokho-ham.github.io/assets/57708971/7259b1d3-07b3-4d63-816a-47e0b0dc9ebb\" width=\"600px\"><br/></p>\n<ul>\n<li>만약 해당하는 플랫폼명이 없다면 예외를 발생시킵니다.</li>\n</ul>\n<p><img src=\"https://github.com/Seokho-Ham/seokho-ham.github.io/assets/57708971/ac5843e1-2ebd-4c25-9281-b30acc890ede\" width=\"800px\"> <br/></p>\n<p><strong>[3]</strong> 리소스 서버에서 유저가 접근허용을 할 경우 parameter에 담긴 redirectUri로 authorization code와 함께 redirect 시킵니다.</p>\n<ul>\n<li>그림에 보이시는 state값은 OAuth2 프로토콜에서 csrf 공격을 방지하기 위해 전송하는것을 권장하고 있습니다.\nSecurity 내부에서는 처음 요청의 state와 응답의 state값을 비교하여 다를 경우 예외를 발생시키고 있습니다.</li>\n</ul>\n<p><strong>여기서부터는 SpringSecurity 내부의 Flow입니다.</strong><br>\n<em>(사진이 작으면 확대해주세요)</em></p>\n<img src=\"https://github.com/Seokho-Ham/seokho-ham.github.io/assets/57708971/3b9e5c4a-731e-4273-b7b9-701b36e51371\">\n<p><strong>[4]</strong> authorization code를 서버가 받게되면 <code class=\"language-text\">OAuthLoginAuthenticationFilter</code>의 attemptAuthentication 메서드에서 해당 요청의 처리를 맡게 됩니다.</p>\n<p><img src=\"https://github.com/Seokho-Ham/seokho-ham.github.io/assets/57708971/dcc3bc15-842a-45db-a3f9-3eec0207a610\" width=\"800px\"> <br/></p>\n<p>해당 메서드의 내부로 가보겠습니다.</p>\n<blockquote>\n<p><strong>코드 내부에서 authorizationRequest, authorizationResponse, redirectUri 객체생성 혹은 검증과 같은 코드도 있지만 이해하는데 필수적이지는 않아서 설명을 제외했습니다.</strong></p>\n</blockquote>\n<p><img src=\"https://github.com/Seokho-Ham/seokho-ham.github.io/assets/57708971/3b5a6e0c-fef8-4811-a175-07ef6612233a\" width=\"900px\"> <br/></p>\n<p><strong>[5]</strong> 다음의 메서드들을 사용하여 AuthorizationCode를 검증합니다. 존재하지 않을 경우 예외를 발생시킵니다.</p>\n<p><img src=\"https://github.com/Seokho-Ham/seokho-ham.github.io/assets/57708971/755872a5-b70e-4731-8580-2cc2ffdccc43\" width=\"800px\"> <br/></p>\n<p><strong>[6~7]</strong> InMemoryClientRegistrationRepository로부터 해당 플랫폼에 맞는 ClientRegistration 객체를 조회해옵니다.</p>\n<p><strong>[8]</strong> 앞에서 설명드린 OAuthProvider의 구현체인 <code class=\"language-text\">OAuth2LoginAuthenticationProvider</code> 에게 <strong>유저 인증</strong>을 요청합니다.</p>\n<ul>\n<li>파라미터로는 유저의 정보를 가져오는데 사용할 토큰을 저장할 추후 SecurityContext에 저장할 <em><code class=\"language-text\">OAuth2LoginAuthenticationToken</code></em> 객체를 전달합니다.</li>\n<li>현재 시점에서는 access, refresh 토큰이 null이며 authenticated 상태도 false입니다.</li>\n</ul>\n<p><img width=\"225\" alt=\"oauth-11\" src=\"https://github.com/Seokho-Ham/seokho-ham.github.io/assets/57708971/0758a840-1368-4a93-883b-a3d60cd24afa\"> <br/></p>\n<p><img src=\"https://github.com/Seokho-Ham/seokho-ham.github.io/assets/57708971/20658e32-6612-4764-b0ef-8be36c29a049\" witdh=\"600px\"> <br/></p>\n<p><strong>[9]</strong> 리소스서버로부터 AccessToken을 요청하는 역할은 OAuth2AuthorizationCodeAuthenticationProvider 클래스가 가지고 있게 때문에 위의 코드에서 볼 수 있듯이 다시한번 authenticate 메서드를 실행합니다.</p>\n<p><img src=\"https://github.com/Seokho-Ham/seokho-ham.github.io/assets/57708971/748a5d25-3963-4d77-8130-3cbcd5b7904f\" width=\"900px\"> <br/></p>\n<p><strong>[10~12]</strong> OAuth2AuthorizationCodeAuthenticationProvider의 authenticate 메서드 내에서는 리소스서버에 accessToken 요청을 하고 있습니다. 이후 응답값을 변환하여 반환합니다.</p>\n<ul>\n<li>OAuth2AuthorizationCodeAuthenticationProvider는 내부에 <strong>요청을 변환하는 converter</strong>와 <strong>resttemplate으로 요청을 보내는 client 객체</strong>를 가지고 있습니다.</li>\n</ul>\n<p><img width=\"540\" alt=\"oauth-14\" src=\"https://github.com/Seokho-Ham/seokho-ham.github.io/assets/57708971/6f0f47f7-d15f-4399-80e8-486e12a21df9\"> <br/></p>\n<p><strong>[13]</strong> OAuth2LoginAuthenticationProvider는 응답받은 AccessToken을 UserRequest 타입의 객체로 <code class=\"language-text\">UserService</code>에게 전달합니다.</p>\n<ul>\n<li>UserRequest 타입의 객체는 내부에 ClientRegistration과 AccessToken을 가지고 있습니다.</li>\n</ul>\n<p><img src=\"https://github.com/Seokho-Ham/seokho-ham.github.io/assets/57708971/e21766b6-708e-4fa1-b3b9-061e34b15e30\" width=\"900px\"> <br/></p>\n<p><strong>[14~16]</strong> DefaultOAuth2UserService의 loadUser 메서드 내부에서는 getResponse라는 메서드를 호출합니다. 해당 시점에 리소스서버로 유저의 정보를 요청힙니다. 이후 응답 받은 데이터를 파싱하여 추상화 된 유저 클래스로 변환한 뒤 반환합니다.</p>\n<ul>\n<li>일반적으로 UserService는 DB에 저장하는 로직을 가지고 있기 때문에 개발자가 직접 작성하게 됩니다.\n이때 SpringSecurity에서 제공하는 DefaultOAuth2UserService를 상속받아서 작성하면 보다 응답값을 사용하여 추가 로직을 작성할 수 있습니다.이 시점에 보통 DB에 저장하는 로직 등이 진행됩니다.</li>\n</ul>\n<p><strong>[17]</strong> 작업이 종료되면 유저 정보를 담은 객체를 AuthenticationProvider에게 반환합니다.</p>\n<p><strong>[18]</strong> 유저 정보를 받은 OAuth2LoginAuthenticationProvider에서는 SecurityContext에 저장할 Authentication 타입의 OAuth2AuthenticationToken 객체로 변환한 뒤 반환합니다.</p>\n<p><img src=\"https://github.com/Seokho-Ham/seokho-ham.github.io/assets/57708971/03d46e9a-7902-4153-8781-3734154bb6ea\" width=\"900px\"> <br/></p>\n<p><strong>[19]</strong> 마지막으로 OAuthLoginAuthenticationFilter 에서는 반환된 정보를 SecurityContext에 저장하게 됩니다.</p>\n<hr>\n<h2 id=\"마무리\" style=\"position:relative;\"><a href=\"#%EB%A7%88%EB%AC%B4%EB%A6%AC\" aria-label=\"마무리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>마무리</h2>\n<p>직접 프로젝트에서 SpringSecurity를 써보지 않고 학습해서 중간중간 코드를 이해하지 못하는 상황\n*(ex. Filter에서 AuthorizedClientService에 저장하는 로직 등)*들도 있었지만 이번 기회를 통해 SpringSecurity에 대한 개념과 Security에서의 OAuth 로그인을 이해할 수 있었습니다. 또한 사이드 프로젝트 리팩토링의 방향성을 얻을 수 있었습니다.\n다음 포스트는 이번에 학습한 내용을 사이드프로젝트 리팩토링에 녹여낸 경험이 될 것 같습니다.</p>\n<h2 id=\"참고자료\" style=\"position:relative;\"><a href=\"#%EC%B0%B8%EA%B3%A0%EC%9E%90%EB%A3%8C\" aria-label=\"참고자료 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>참고자료</h2>\n<ul>\n<li><a href=\"https://docs.spring.io/spring-security/site/docs/3.2.10.RELEASE/reference/htmlsingle/html5/#what-is-acegi-security\">https://docs.spring.io/spring-security/site/docs/3.2.10.RELEASE/reference/htmlsingle/html5/#what-is-acegi-security</a></li>\n<li><a href=\"https://www.callicoder.com/spring-boot-security-oauth2-social-login-part-2/\">https://www.callicoder.com/spring-boot-security-oauth2-social-login-part-2/</a></li>\n<li><a href=\"https://mangkyu.tistory.com/76\">https://mangkyu.tistory.com/76</a></li>\n<li><a href=\"https://velog.io/@max9106/OAuth3\">https://velog.io/@max9106/OAuth3</a></li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#%EC%84%9C%EB%A1%A0\">서론</a></li>\n<li><a href=\"#springsecurity\">SpringSecurity?</a></li>\n<li><a href=\"#springsecurity%EB%8A%94-%EC%96%B4%EB%96%BB%EA%B2%8C-%EC%97%AC%EB%9F%AC-%ED%94%8C%EB%9E%AB%ED%8F%BC%EC%97%90-%EB%8C%80%ED%95%B4-%EC%9C%A0%EC%97%B0%ED%95%98%EA%B2%8C-%EC%B2%98%EB%A6%AC%ED%95%98%EB%8A%94%EA%B0%80\">SpringSecurity는 어떻게 여러 플랫폼에 대해 유연하게 처리하는가?</a></li>\n<li><a href=\"#springsecurity%EA%B0%80-oauth%EB%A1%9C%EA%B7%B8%EC%9D%B8%EC%9D%84-%EC%B2%98%EB%A6%AC%ED%95%98%EB%8A%94-%EA%B3%BC%EC%A0%95\">SpringSecurity가 OAuth로그인을 처리하는 과정</a></li>\n<li><a href=\"#%EB%A7%88%EB%AC%B4%EB%A6%AC\">마무리</a></li>\n<li><a href=\"#%EC%B0%B8%EA%B3%A0%EC%9E%90%EB%A3%8C\">참고자료</a></li>\n</ul>\n</div>","excerpt":"서론 저는 이전에 참여했던 사이드 프로젝트 에서 OAuth 로그인 개발을 담당했습니다. 그리고 이번에 프로젝트 리팩토링을 계획하면서 가장 마음에 안들던 로그인 관련 코드를 개선하기로 결정했습니다. 최초 기획에서는 카카오 로그인만을 사용하기로 했기 때문에 카카오 로그인에 맞게 코드를 작성하였고, 현재 로그인 관련 코드는 카카오 로그인에 종속적인 코드입니다. 때문에 새로운 로그인 방식을 도입하기에도 까다로운 상황이라 이번 기회에 OAuth 로그인 관련 코드를 개선하기로 했습니다. OAuth 관련 클래스들을 추상화하기 위해 고민하던 중 SpringSecurity에서는 어떻게 여러개의 플랫폼에 쉽게 대응할 수 있도록 했는지, 실제 내부 동작은 어떻게 동작하는지 궁금해졌고 그래서 디버깅을 통해 내부 동작을 학습해보았습니다. SpringSecurity? 공식문서에서는 애플리케이션 보안(특히 유저의 인증, 인가)을 관리하기 위해 제공되는 프레임워크라고 설명합니다.\n대표적인 특징으로는 Sprin…","frontmatter":{"date":"March 05, 2023","title":"SpringSecurity가 OAuth 로그인을 처리하는 과정 파헤치기","categories":"Spring","author":"서코코","emoji":"🌱"},"fields":{"slug":"/backend/spring/spring-security-and-oauth/"}},"next":{"id":"62c08c2a-7557-516e-a4bc-627c59fe68cc","html":"<h2 id=\"서론\" style=\"position:relative;\"><a href=\"#%EC%84%9C%EB%A1%A0\" aria-label=\"서론 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>서론</h2>\n<p>최근 진행했던 식도락 프로젝트에서 유저의 피드 목록을 페이징 처리를 하여 제공하는 api를 개발했습니다.</p>\n<p>해당 api는 sns 특성상 페이지 단위로 제공하기보다는 <strong>무한 스크롤 형식</strong>에 <strong>최근 작성한 순서</strong>로 데이터를 제공해야 했습니다.</p>\n<p>페이징 방식을 고민하던 중 offset과 no-offset 방식이 있고 offset 방식을 사용하면 매번 full-scan을 하여 성능적으로 좋지 않다는 것을 알게 되어 개발 당시에는 곧바로 no-offset 방식을 도입하여 개발하였습니다.\n하지만 실제로 offset 방식과 no-offset 방식의 성능 차이가 얼마나 나는지 눈으로 확인하기 위해 두가지 방식을 모두 적용하여 성능을 비교해보기로 하였습니다.</p>\n<hr>\n<h2 id=\"offset이란\" style=\"position:relative;\"><a href=\"#offset%EC%9D%B4%EB%9E%80\" aria-label=\"offset이란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>offset이란?</h2>\n<p>offset 이란 sql에서 조회를 시작할 기준점을 의미합니다. limit은 조회할 결과의 개수를 의미합니다.\n예를 들어 아래와 같은 쿼리가 있을 경우 5000번째 행부터 10개의 행을 읽겠다는 의미입니다. (이때 행은 0부터 시작합니다.)</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span>\n<span class=\"token keyword\">FROM</span> TABLE_NAME\n<span class=\"token keyword\">LIMIT</span> <span class=\"token number\">10</span>\n<span class=\"token keyword\">OFFSET</span> <span class=\"token number\">5000</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>offset은 조회를 한 결과에서 limit으로 지정한 개수만큼만 반환하고 나머지는 버리는 방식으로 동작합니다. 위의 쿼리를 예로 들면 5000번째 데이터부터 10개를 조회하기 위해서는 5010개의 데이터를 모두 읽은 뒤, 앞의 필요하지 않은 5000개는 버려야합니다.</p>\n<p>적은 양의 데이터를 조회할때는 성능적인 문제가 발생하지 않지만 <strong>전체 데이터의 개수가 많아질수록 앞에 읽어야하는 데이터의 양이 많아져 문제가 됩니다.</strong></p>\n<p>추가적으로 저는 offset 방식은 무한 스크롤에 적합하지 않다고 생각합니다.</p>\n<p>유저가 피드를 조회한다고 가정하고 예를 들어 보겠습니다.\n(데이터는 생성 순서대로 제공된다고 가정합니다.)</p>\n<ul>\n<li>사용자가 1번~10번 리뷰를 조회했습니다.</li>\n<li>이 시점에 새로운 데이터가 추가되었습니다.</li>\n<li>11번~20번 리뷰를 이어서 조회합니다.</li>\n</ul>\n<p>새로운 데이터가 추가 되었기 때문에 리뷰의 개수는 총 21개가 되며 기존 10번째 행에 있는 리뷰가 11번째 행으로 밀려나게 되고, 사용자는 원래대로 11<del>20번째 리뷰를 조회하게 됩니다. 여기서 문제가 발생하는데 offset 방식은 단순히 21개의 데이터 중 11</del>20번째 행을 결과로 반환할것입니다. 그러면 스크롤을 내리는 사용자의 화면에는 <strong>리뷰(기존 10번째 리뷰)가 중복되어 보이게 됩니다.</strong>\n(물론 애플리케이션에서 추가적인 코드를 작성하여 해당 문제는 해결할 수 있겠지만 이것 자체가 비용이 발생하는것이고 곧 단점이라고 생각됩니다.)</p>\n<p>위의 문제들을 해결하기 위해 저희 서비스에서는 no-offset방식을 적용하였습니다.</p>\n<hr>\n<h2 id=\"그렇다면-no-offset은-뭘까요\" style=\"position:relative;\"><a href=\"#%EA%B7%B8%EB%A0%87%EB%8B%A4%EB%A9%B4-no-offset%EC%9D%80-%EB%AD%98%EA%B9%8C%EC%9A%94\" aria-label=\"그렇다면 no offset은 뭘까요 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>그렇다면 no-offset은 뭘까요?</h2>\n<p>이름 그대로 offset을 사용하지 않고 특정 id를 기준점으로 잡아 where절을 사용하여 데이터를 조회하는 방식입니다.</p>\n<p>이 방식을 사용할 경우 기준점 이전의 데이터도 모두 조회하던 offset과 달리 기준점인 id부터 limit의 개수만 조회하기 때문에 데이터의 개수가 많아져도 성능문제가 발생하지 않습니다.</p>\n<p>이어서 각각의 방식을 사용하여 실제 구현한 코드와 테스트를 통해 성능을 비교해보겠습니다.<br>\n동일한 환경으로 테스트를 진행했습니다.</p>\n<h3 id=\"테스트-환경\" style=\"position:relative;\"><a href=\"#%ED%85%8C%EC%8A%A4%ED%8A%B8-%ED%99%98%EA%B2%BD\" aria-label=\"테스트 환경 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>테스트 환경</h3>\n<ul>\n<li>리뷰 데이터 : 10,000,000건</li>\n<li>유저 데이터 : 1000명</li>\n<li>테스트 시나리오 : 1번 유저가 999명을 팔로우하고 있으며, 1번 유저의 정보로 피드를 조회하도록 요청 (이때 조회할 데이터의 번호는 랜덤입니다.)</li>\n</ul>\n<h3 id=\"1-offset-방식의-구현과-성능\" style=\"position:relative;\"><a href=\"#1-offset-%EB%B0%A9%EC%8B%9D%EC%9D%98-%EA%B5%AC%ED%98%84%EA%B3%BC-%EC%84%B1%EB%8A%A5\" aria-label=\"1 offset 방식의 구현과 성능 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. offset 방식의 구현과 성능</h3>\n<p>아래는 실제 저희 서비스에서 유저의 피드를 조회하는 메서드입니다.<br>\n메서드의 2번째 파라미터로 페이지 번호와 반환받을 데이터의 개수가 있는 Pageable 타입의 객체를 넘겨줍니다</p>\n<img width=\"559\" alt=\"offset-1\" src=\"https://github.com/Seokho-Ham/seokho-ham.github.io/assets/57708971/72f4beab-35da-48fe-a23f-b911da4936c4\">\n<ul>\n<li>여기서 Pageable 인터페이스의 실제 구현체인 PageRequest 클래스를 사용하여 객체를 만듭니다.\n<ul>\n<li>cursor가 페이지 번호, size가 limit을 의미합니다.</li>\n</ul>\n</li>\n</ul>\n<p><img width=\"224\" alt=\"offset-2\" src=\"https://github.com/Seokho-Ham/seokho-ham.github.io/assets/57708971/6564a564-6487-445b-8c21-ec2071ee4337\"> <br/></p>\n<p>다음은 실제 나가는 쿼리입니다. 보시는바와 같이 offset이 적용되어 있습니다.</p>\n<img src=\"https://github.com/Seokho-Ham/seokho-ham.github.io/assets/57708971/8c9a19e8-ea02-4121-b31c-482cfcbcccc1\" width=\"600px\">\n<p>다음은 ngrinder를 사용하여 위에 적어둔 환경으로 3분간 테스트를 진행한 결과입니다.</p>\n<ul>\n<li><strong>초당 처리한 요청의 개수 : 1.5개</strong></li>\n<li><strong>요청당 평균 응답 속도 : 약 31초</strong></li>\n<li>**실패한 요청 개수 : 147개 **</li>\n</ul>\n<p><img src=\"https://github.com/Seokho-Ham/seokho-ham.github.io/assets/57708971/865f3959-b716-4f8d-a408-8369b49ce378\"> <br/></p>\n<p><img src=\"https://github.com/Seokho-Ham/seokho-ham.github.io/assets/57708971/7fb186c4-2854-40de-80f7-ca6ea5e1ff1d\"> <br/></p>\n<p>많은 요청들이 위와 같이 Connection Pool로부터 커넥션을 가져오지 못해 ConnectionTimeout Exception이 발생하는것을 볼 수 있습니다.</p>\n<p>다음으로는 no-offset 방식과 실제 테스트 결과를 보여드리겠습니다.</p>\n<br/>\n<h3 id=\"2-no-offset-방식의-구현과-성능\" style=\"position:relative;\"><a href=\"#2-no-offset-%EB%B0%A9%EC%8B%9D%EC%9D%98-%EA%B5%AC%ED%98%84%EA%B3%BC-%EC%84%B1%EB%8A%A5\" aria-label=\"2 no offset 방식의 구현과 성능 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. no-offset 방식의 구현과 성능</h3>\n<p>offset 방식의 메서드와 동일하지만 파라미터로 target id가 추가되었습니다.<br>\n(최신 데이터부터 반환해야되기 때문에 조건이 &#x3C;=로 되어 있습니다.)</p>\n<p><img src=\"https://github.com/Seokho-Ham/seokho-ham.github.io/assets/57708971/ebe7d6eb-e81e-420e-921b-85b4ac9d8f29\" width=\"600px\"> <br/></p>\n<p>다음은 실제 실행되는 쿼리입니다.</p>\n<img src=\"https://github.com/Seokho-Ham/seokho-ham.github.io/assets/57708971/840282ce-4d38-42b4-9d3f-9e0eddf6ce30\" width=\"600px\">\n<ul>\n<li>여기서는 offset이 필요하지 않기 때문에 limit 역할을 하는 size만 Pageable 객체에 담습니다.\n<ul>\n<li>내부적으로는 PageRequest 구현체를 사용합니다.</li>\n</ul>\n</li>\n</ul>\n<img width=\"178\" alt=\"offset-8\" src=\"https://github.com/Seokho-Ham/seokho-ham.github.io/assets/57708971/5d064ada-9158-45fd-8200-9f2d4c12db54\">\n<p>아래는 동일한 환경에서 진행한 테스트를 결과입니다.</p>\n<ul>\n<li><strong>초당 처리한 요청의 개수 : 197개</strong></li>\n<li><strong>요청당 평균 응답 속도 : 약 0.5초</strong></li>\n<li><strong>실패한 요청 개수 : 0개</strong></li>\n</ul>\n<img src=\"https://github.com/Seokho-Ham/seokho-ham.github.io/assets/57708971/a3611462-2e03-4d39-b22b-6aa4542ba74f\">\n<p>2가지 방식의 성능차이를 비교하면 아래와 같습니다.</p>\n<ul>\n<li><strong>초당 처리한 요청의 개수 : <span style=\"color:red\">1.5개</span> -><span style=\"color:blue\"> 197개 (32배 향상)</span></strong></li>\n<li><strong>요청당 평균 응답 속도 : <span style=\"color:red\">약 31초</span> -><span style=\"color:blue\"> 약 0.5초 (60배 향상)</span></strong></li>\n<li><strong>실패한 요청 개수 : <span style=\"color:red\">147개</span> -><span style=\"color:blue\"> 0</span></strong></li>\n</ul>\n<p>추가적으로 리뷰데이터 백만건을 가지고도 테스트를 진행해보았습니다.</p>\n<ul>\n<li><strong>초당 처리한 요청의 개수 : <span style=\"color:red\">12개</span> -><span style=\"color:blue\"> 214개 (17배 향상)</span></strong></li>\n<li><strong>요청당 평균 응답 속도 : <span style=\"color:red\">약 8.3초</span> -><span style=\"color:blue\"> 약 0.48초 (16배 향상)</span></strong></li>\n<li><strong>실패한 요청 개수 : <span style=\"color:red\">147개</span> -><span style=\"color:blue\"> 0</span></strong></li>\n</ul>\n<img src=\"https://github.com/Seokho-Ham/seokho-ham.github.io/assets/57708971/8f992ea3-3c77-49fa-ba2a-df11385152f5\" width=\"600px\">\n<p>결과에서 알 수 있듯이 눈에 띄게 성능이 심하게 차이가 났으며 데이터가 많을수록 그 차이는 컸습니다.</p>\n<hr>\n<h2 id=\"한줄-마무리\" style=\"position:relative;\"><a href=\"#%ED%95%9C%EC%A4%84-%EB%A7%88%EB%AC%B4%EB%A6%AC\" aria-label=\"한줄 마무리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>한줄 마무리</h2>\n<p>직접 테스트를 진행한 덕분에 각 방식의 동작하는 과정과 성능적으로 얼마나 차이가 나는지에 대해 알 수 있었습니다.</p>\n<p>하지만 결국 서비스의 특성에 맞춰 사용할 방식을 정하고 추후 성능을 개선하는것이 가장 좋은 해결책인것 같습니다.</p>\n<br/>\n<h2 id=\"feat-성능비교-과정에서-고려하지-못한-점\" style=\"position:relative;\"><a href=\"#feat-%EC%84%B1%EB%8A%A5%EB%B9%84%EA%B5%90-%EA%B3%BC%EC%A0%95%EC%97%90%EC%84%9C-%EA%B3%A0%EB%A0%A4%ED%95%98%EC%A7%80-%EB%AA%BB%ED%95%9C-%EC%A0%90\" aria-label=\"feat 성능비교 과정에서 고려하지 못한 점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>feat. 성능비교 과정에서 고려하지 못한 점</h2>\n<p>최초 성능비교를 위한 테스트를 하는 시점에는 인메모리로 h2를 사용했습니다.</p>\n<h3 id=\"1-out-of-memory\" style=\"position:relative;\"><a href=\"#1-out-of-memory\" aria-label=\"1 out of memory permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. Out of Memory</h3>\n<p><strong>[문제]</strong></p>\n<p>1,000,000건까지는 데이터가 잘 들어갔지만 10,000,000건부터는 OutOfMemory라는 에러메세지와 함께 데이터가 들어가지 않았습니다.</p>\n<p><strong>[해결]</strong></p>\n<p>H2 공식문서에서 찾아보니 Embedded 모드로 사용하면 실행하는 애플리케이션과 동일한 jvm 위에서 돌아간다는것을 알았습니다.</p>\n<p>해결방법으로는 앱 실행 시 옵션을 줘서 최대 메모리 용량을 늘려주는 방법이 있었습니다. (jvm은 실행 시 기본적으로 최대 메모리 용량을 256mb로 설정한다고 합니다.)</p>\n<p>하지만 매번 실행될때마다 데이터를 새로 넣는것은 비효율적일것 같아 로컬에서 도커 컨테이너로 mysql을 사용하도록 변경하였습니다.</p>\n<h3 id=\"2-인메모리-db와-도커의-성능-차이-미해결\" style=\"position:relative;\"><a href=\"#2-%EC%9D%B8%EB%A9%94%EB%AA%A8%EB%A6%AC-db%EC%99%80-%EB%8F%84%EC%BB%A4%EC%9D%98-%EC%84%B1%EB%8A%A5-%EC%B0%A8%EC%9D%B4-%EB%AF%B8%ED%95%B4%EA%B2%B0\" aria-label=\"2 인메모리 db와 도커의 성능 차이 미해결 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. 인메모리 DB와 도커의 성능 차이 (미해결..)</h3>\n<p>인메모리 DB를 사용하여 테스트할떄는 평균 응답속도가 4초~6가 나오는 반면 로컬에서 도커 컨테이너로 mysql을 띄우고 실행했을때는 0.5초밖에 걸리지 않았습니다. 당연히 메모리상의 DB가 더 빠른 성능을 보여줄것이라고 생각했지만.. 아무래도 같은 jvm 위에서 실행되며 해당 애플리케이션의 쓰레드를 통해 I/O 작업이 발생하기 때문에 부하가 많아질수록 DB 성능도 떨어지는게 아닐까라고 생각됩니다.</p>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#%EC%84%9C%EB%A1%A0\">서론</a></p>\n</li>\n<li>\n<p><a href=\"#offset%EC%9D%B4%EB%9E%80\">offset이란?</a></p>\n</li>\n<li>\n<p><a href=\"#%EA%B7%B8%EB%A0%87%EB%8B%A4%EB%A9%B4-no-offset%EC%9D%80-%EB%AD%98%EA%B9%8C%EC%9A%94\">그렇다면 no-offset은 뭘까요?</a></p>\n<ul>\n<li><a href=\"#%ED%85%8C%EC%8A%A4%ED%8A%B8-%ED%99%98%EA%B2%BD\">테스트 환경</a></li>\n<li><a href=\"#1-offset-%EB%B0%A9%EC%8B%9D%EC%9D%98-%EA%B5%AC%ED%98%84%EA%B3%BC-%EC%84%B1%EB%8A%A5\">1. offset 방식의 구현과 성능</a></li>\n<li><a href=\"#2-no-offset-%EB%B0%A9%EC%8B%9D%EC%9D%98-%EA%B5%AC%ED%98%84%EA%B3%BC-%EC%84%B1%EB%8A%A5\">2. no-offset 방식의 구현과 성능</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%ED%95%9C%EC%A4%84-%EB%A7%88%EB%AC%B4%EB%A6%AC\">한줄 마무리</a></p>\n</li>\n<li>\n<p><a href=\"#feat-%EC%84%B1%EB%8A%A5%EB%B9%84%EA%B5%90-%EA%B3%BC%EC%A0%95%EC%97%90%EC%84%9C-%EA%B3%A0%EB%A0%A4%ED%95%98%EC%A7%80-%EB%AA%BB%ED%95%9C-%EC%A0%90\">feat. 성능비교 과정에서 고려하지 못한 점</a></p>\n<ul>\n<li><a href=\"#1-out-of-memory\">1. Out of Memory</a></li>\n<li><a href=\"#2-%EC%9D%B8%EB%A9%94%EB%AA%A8%EB%A6%AC-db%EC%99%80-%EB%8F%84%EC%BB%A4%EC%9D%98-%EC%84%B1%EB%8A%A5-%EC%B0%A8%EC%9D%B4-%EB%AF%B8%ED%95%B4%EA%B2%B0\">2. 인메모리 DB와 도커의 성능 차이 (미해결..)</a></li>\n</ul>\n</li>\n</ul>\n</div>","frontmatter":{"date":"January 06, 2023","title":"offset과 no offset을 사용한 페이징 성능 차이 분석","categories":"Database","author":"서코코","emoji":"🌱"},"fields":{"slug":"/backend/database/offset-nooffset/"}},"prev":{"id":"7d0c0069-5b0a-5c37-94d4-e78df4a463fe","html":"<h2 id=\"서론\" style=\"position:relative;\"><a href=\"#%EC%84%9C%EB%A1%A0\" aria-label=\"서론 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>서론</h2>\n<p><a href=\"https://seokho-ham.github.io/backend/spring/spring-security-and-oauth/\">이전 글</a>에서 SpringSecurity가 OAuth 로그인을 처리하는 과정을 디버깅을 통해 학습했습니다.</p>\n<p>학습경험을 바탕으로 식도락 프로젝트의 기존 OAuth 로그인 코드를 개선한 과정에 대해 글을 써보려 합니다.</p>\n<hr>\n<h2 id=\"기존의-문제점\" style=\"position:relative;\"><a href=\"#%EA%B8%B0%EC%A1%B4%EC%9D%98-%EB%AC%B8%EC%A0%9C%EC%A0%90\" aria-label=\"기존의 문제점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>기존의 문제점</h2>\n<h3 id=\"카카오-로그인에-의존적이며-확장에-닫혀있는-코드\" style=\"position:relative;\"><a href=\"#%EC%B9%B4%EC%B9%B4%EC%98%A4-%EB%A1%9C%EA%B7%B8%EC%9D%B8%EC%97%90-%EC%9D%98%EC%A1%B4%EC%A0%81%EC%9D%B4%EB%A9%B0-%ED%99%95%EC%9E%A5%EC%97%90-%EB%8B%AB%ED%98%80%EC%9E%88%EB%8A%94-%EC%BD%94%EB%93%9C\" aria-label=\"카카오 로그인에 의존적이며 확장에 닫혀있는 코드 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>카카오 로그인에 의존적이며 확장에 닫혀있는 코드.</h3>\n<p>새로운 플랫폼을 지원하도록 확장하기 위해서는 요청을 보내는 클라이언트뿐만 아니라 비즈니스로직이 담긴 서비스 클래스까지 변경이 발생합니다. 또한 추가적으로 작성해야되는 클래스가 너무 많이 필요합니다.</p>\n<ul>\n<li><strong>Properties 클래스의 주입.</strong><br>\n기존의 서비스 코드에서는 카카오api 사용에 필요한 정보를 담은 KakaoProperties 클래스를 직접 주입받아서 사용하고 있었습니다. 즉, 새로운 플랫폼을 지원할때마다 주입받아야하는 클래스가 늘어나야 했으며 요청 형태에 따라 조건문으로 구별해서 사용해야 했습니다.</li>\n</ul>\n<p><img src=\"https://github.com/Seokho-Ham/seokho-ham.github.io/assets/57708971/dd3db9d1-87a2-4d29-b8e9-04204891c8e6\" width=\"600px\"> <br/></p>\n<p><img width=\"589\" alt=\"re-2\" src=\"https://github.com/Seokho-Ham/seokho-ham.github.io/assets/57708971/13ef419f-3822-445a-97bc-f3cb0e5bc121\"> <br/></p>\n<ul>\n<li><strong>Response 객체.</strong><br>\n응답을 담든 Response 객체가 카카오의 응답형태에 종속적이었습니다.\n중요한건 서버에 저장할 도메인 객체인 User 클래스이지만 기존 구조에서는 이와 직접적으로 관련없는 Response 클래스를 각 플랫폼별로 만들어야했습니다.</li>\n</ul>\n<p><img src=\"https://github.com/Seokho-Ham/seokho-ham.github.io/assets/57708971/07d9b671-3cc2-48c4-9d49-2c7cf9321ead\" width=\"800px\"> <br/></p>\n<ul>\n<li><strong>Client 객체</strong><br>\n요청을 보내는 클라이언트 객체가 카카오 api에 종속적이었습니다.\n플랫폼을 늘리기 위해서는 해당 코드가 동적으로 동작할 수 있도록 개선해야했습니다.</li>\n</ul>\n<p><img src=\"https://github.com/Seokho-Ham/seokho-ham.github.io/assets/57708971/e21b50c1-3870-43be-8190-f046251ed627\" width=\"800px\"> <br/>\n<img src=\"https://github.com/Seokho-Ham/seokho-ham.github.io/assets/57708971/5f525099-d69b-43a5-befd-c7f30b08a0b5\" width=\"800px\"> <br/></p>\n<hr>\n<h2 id=\"개선-과정\" style=\"position:relative;\"><a href=\"#%EA%B0%9C%EC%84%A0-%EA%B3%BC%EC%A0%95\" aria-label=\"개선 과정 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>개선 과정</h2>\n<h3 id=\"1-구성정보-객체-추상화-및-동적사용\" style=\"position:relative;\"><a href=\"#1-%EA%B5%AC%EC%84%B1%EC%A0%95%EB%B3%B4-%EA%B0%9D%EC%B2%B4-%EC%B6%94%EC%83%81%ED%99%94-%EB%B0%8F-%EB%8F%99%EC%A0%81%EC%82%AC%EC%9A%A9\" aria-label=\"1 구성정보 객체 추상화 및 동적사용 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. 구성정보 객체 추상화 및 동적사용</h3>\n<p>각각의 플랫폼에 맞는 Properties 클래스를 일일이 만들고 매번 이를 직접 주입받아서 사용하는건 좋은 방법이 아닌것 같습니다.</p>\n<p>이를 개선하기 위해 SpringSecurity의 <code class=\"language-text\">InMemoryClientRegistrationRepository</code> 클래스를 참고하여 저희 서비스에서 사용할 <code class=\"language-text\">InMemoryClientRegistrationRepository</code> 를 직접 작성했습니다.<br>\n(해당 내용이 궁금하다면 <a href=\"https://seokho-ham.github.io/backend/spring/spring-security-and-oauth/\">이전 글</a>을 참고해주세요.)</p>\n<ul>\n<li>인메모리가 아닌 외부 환경을 이용하는 상황을 대비해 ClientRegistrationRepository 인터페이스를 두고 구현체를 사용하였습니다.</li>\n</ul>\n<p><img src=\"https://github.com/Seokho-Ham/seokho-ham.github.io/assets/57708971/5a595a57-e2dd-4adb-b8bf-128852507deb\" width=\"600px\"> <br/>\n<img src=\"https://github.com/Seokho-Ham/seokho-ham.github.io/assets/57708971/8023ce0f-d6ae-4dd0-8899-b350184aa85d\" width=\"800px\"> <br/></p>\n<p>저장소를 만들었으니 이제는 실제 구성정보를 담는 객체를 추상화해야 합니다. OAuthClientRegistration 클래스를 작성하였고, 해당 클래스는 2가지 클래스를 조합하여 만들기로 결정했습니다.</p>\n<p><img src=\"https://github.com/Seokho-Ham/seokho-ham.github.io/assets/57708971/21d8ab2d-fb60-4a59-8614-51768f76dfbc\" width=\"800px\"> <br/></p>\n<p>Registration 객체를 만들기 위해 먼저는 clientId, secret 등을 가지고 있는 기존의 Properties 객체와 같은 클래스가 필요합니다.</p>\n<p>다행히도 OAuth 프로토콜에서는 해당 플랫폼을 이용하기 위해 필요한 정보와 요청 형태가 표준화 되어 있습니다. 덕분에 공통된 하나의 타입의 클래스인 <strong>OAuthRegistrationProperty</strong> 클래스를 만들어 이를 해결하였습니다.</p>\n<p>두번째는 <strong>Converter 클래스</strong>입니다.\n플랫폼별로 유저정보의 응답형태가 조금씩 다릅니다. 예를들어 카카오는 유저 이름이 nickname이라는 필드로 제공되는 반면, google의 경우 name으로 제공됩니다. 이렇게 조금씩 다른 응답을 공통된 형태의 응답객체로 사용하고 싶었습니다. 이를 위해 해당 플랫폼에 맞는 Converter를 그때그때 직접 구현하기로 결정하였습니다.</p>\n<p><img src=\"https://github.com/Seokho-Ham/seokho-ham.github.io/assets/57708971/dcce9dd9-6fb7-40df-b4fc-f09c15d683b7\" width=\"800px\"> <br/></p>\n<p><img src=\"https://github.com/Seokho-Ham/seokho-ham.github.io/assets/57708971/d18b30d6-7a29-42f5-9379-2dd73fd39c5f\" width=\"800px\"> <br/></p>\n<p>개선 후의 구체적인 동작흐름은 다음과 같습니다.</p>\n<p><strong>1.</strong> 애플리케이션 실행 시 application.yml에 작성된 구성정보를 읽어 OAuthClientProperty 클래스들이 Map에 등록됩니다.<br>\n이때 각 플랫폼으로부터 오는 응답을 공통된 형태의 객체로 변환해 줄 Converter 클래스도 함께 등록됩니다.</p>\n<p><img src=\"https://github.com/Seokho-Ham/seokho-ham.github.io/assets/57708971/242c6bc5-8678-447e-bfeb-642277846c96\" width=\"600px\"> <br/></p>\n<p><strong>2.</strong> 프로퍼티 객체들과 컨버터 객체들을 조합하여 플랫폼별 OAuthClientRegistration 클래스를 생성하고 InMemoryClientRegistrationRepository에 등록합니다.</p>\n<ul>\n<li>생성자에서 createRegistrationMap 메서드가 호출되고 이 시점에 Property 객체와 Converter 객체를 조합해 플랫폼별 Registration 클래스를 생성합니다.</li>\n</ul>\n<p><img src=\"https://github.com/Seokho-Ham/seokho-ham.github.io/assets/57708971/7e7a70fc-c8aa-4f21-97e8-40df4043d3cb\" width=\"800px\"> <br/></p>\n<p>이를 통해 기존에 특정 Property 객체를 직접 주입받아 사용하던 서비스의 코드를 제거할 수 있었으며, 각각 다른 Response 타입을 만드는 대신 Converter를 사용해 공통적으로 사용할 OAuthUserProfile이라는 클래스 타입으로 사용할 수 있었습니다.<br>\n더 나아가 요청 형태에 따라 사용할 플랫폼 정보를 동적으로 사용할 수 있도록 개선하였습니다.</p>\n<p><img src=\"https://github.com/Seokho-Ham/seokho-ham.github.io/assets/57708971/a77a78db-becd-4e6f-ae81-3d7605aab337\" width=\"800px\"> <br/></p>\n<h3 id=\"2-client-객체\" style=\"position:relative;\"><a href=\"#2-client-%EA%B0%9D%EC%B2%B4\" aria-label=\"2 client 객체 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. Client 객체</h3>\n<p>기존에 사용하던 클라이언트 객체를 요청할 플랫폼에 상관없이 재사용하고 싶었습니다.<br>\n이를 위해 FeignClient 문서를 찾아보다 요청의 첫번째 인자로 URI 타입의 정보를 넘겨주면 요청 uri를 동적으로 설정할 수 있다는 사실을 알게 되었습니다.</p>\n<p><img src=\"https://github.com/Seokho-Ham/seokho-ham.github.io/assets/57708971/7b8b180d-9a49-45eb-befb-2bd80d738614\" width=\"800px\"> <br/></p>\n<p>이를 통해 서비스 코드에서는 하나의 Client 객체만으로 모든 OAuth 관련 요청을 처리할 수 있게 되었습니다.</p>\n<ul>\n<li><strong>getOAuthAccessToken</strong>: 유저의 정보를 요청할때 필요한 access token을 요청하는 메서드입니다.\n필수적으로 필요한 정보를 registration으로부터 꺼내 body에 담아 요청합니다.</li>\n<li><strong>getOAuthUserInformation</strong>: 유저의 정보를 요청하는 메서드입니다.\n(이때 kakao의 경우 응답 json의 depth가 2~3까지 들어가는 반면 github은 1입니다. 이 정보들을 평탄화하여 map에 저장하는 작업을 FeignClient Deserializer에서 합니다.)</li>\n</ul>\n<p><img src=\"https://github.com/Seokho-Ham/seokho-ham.github.io/assets/57708971/7d800805-36b9-4b80-86f9-b69985f99808\" width=\"800px\"> <br/></p>\n<p><img src=\"https://github.com/Seokho-Ham/seokho-ham.github.io/assets/57708971/7998b377-ea0f-4d63-bda1-1536a40d2932\" width=\"800px\"> <br/></p>\n<hr>\n<h2 id=\"최종-개선\" style=\"position:relative;\"><a href=\"#%EC%B5%9C%EC%A2%85-%EA%B0%9C%EC%84%A0\" aria-label=\"최종 개선 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>최종 개선</h2>\n<p>아래는 결과적으로 개선된 코드입니다.</p>\n<p><strong>1.</strong> Controller 레이어에서 해당 플랫폼을 처리할 수 있는 Registration 객체를 찾아 서비스에 전달합니다.<br>\n<strong>2.</strong> 서비스에서는 access token, user 정보를 차례대로 요청합니다. 이때 플랫폼 상관없이 공통된 타입의 객체로 응답을 처리합니다.<br>\n<strong>3.</strong> Converter를 사용해 받은 응답으로부터 서비스에서 필요한 정보들만 뽑아 OAuthUserProfile 객체를 만든 뒤, 유저를 저장하는 로직을 처리합니다.</p>\n<p><img src=\"https://github.com/Seokho-Ham/seokho-ham.github.io/assets/57708971/47e00c4a-347b-4d9d-b281-40a0e5b4d498\" width=\"800px\"> <br/></p>\n<hr>\n<h2 id=\"마무리\" style=\"position:relative;\"><a href=\"#%EB%A7%88%EB%AC%B4%EB%A6%AC\" aria-label=\"마무리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>마무리</h2>\n<p>지금까지 유연한 OAuth 로그인 처리를 위해 기존의 코드를 개선한 과정을 작성해보았습니다.<br>\n기존 코드에서 새로운 플랫폼을 지원하려고 한다면 아래와 같은 작업들이 필요했습니다.</p>\n<ul>\n<li>새로운 Properties 작성, Client 클래스 작성</li>\n<li>플랫폼의 응답을 처리할 Response 클래스 작성</li>\n<li>Service 객체에서 새로운 Properties 주입 후 조건문을 통한 동적 사용\n동시에 실제 비즈니스 로직이 변경되는것이 아님에도 불구하고 서비스의 코드에 변경이 반영되어야 했습니다.</li>\n</ul>\n<p>하지만 개선한 뒤에는 아래 2가지 작업만 하면 새로운 플랫폼을 지원할 수 있도록 변경되었습니다.</p>\n<ul>\n<li>application.yml에 구성정보 작성</li>\n<li>응답을 처리할 컨버터 클래스 작성</li>\n</ul>\n<p>결과적으로 기존 코드를 직접 개선하는 경험을 통해 확장에 유연한 코드의 중요성에 대해 더 체감할 수 있었으며 리팩토링의 즐거움 또한 알 수 있었습니다.</p>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#%EC%84%9C%EB%A1%A0\">서론</a></p>\n</li>\n<li>\n<p><a href=\"#%EA%B8%B0%EC%A1%B4%EC%9D%98-%EB%AC%B8%EC%A0%9C%EC%A0%90\">기존의 문제점</a></p>\n<ul>\n<li><a href=\"#%EC%B9%B4%EC%B9%B4%EC%98%A4-%EB%A1%9C%EA%B7%B8%EC%9D%B8%EC%97%90-%EC%9D%98%EC%A1%B4%EC%A0%81%EC%9D%B4%EB%A9%B0-%ED%99%95%EC%9E%A5%EC%97%90-%EB%8B%AB%ED%98%80%EC%9E%88%EB%8A%94-%EC%BD%94%EB%93%9C\">카카오 로그인에 의존적이며 확장에 닫혀있는 코드.</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EA%B0%9C%EC%84%A0-%EA%B3%BC%EC%A0%95\">개선 과정</a></p>\n<ul>\n<li><a href=\"#1-%EA%B5%AC%EC%84%B1%EC%A0%95%EB%B3%B4-%EA%B0%9D%EC%B2%B4-%EC%B6%94%EC%83%81%ED%99%94-%EB%B0%8F-%EB%8F%99%EC%A0%81%EC%82%AC%EC%9A%A9\">1. 구성정보 객체 추상화 및 동적사용</a></li>\n<li><a href=\"#2-client-%EA%B0%9D%EC%B2%B4\">2. Client 객체</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EC%B5%9C%EC%A2%85-%EA%B0%9C%EC%84%A0\">최종 개선</a></p>\n</li>\n<li>\n<p><a href=\"#%EB%A7%88%EB%AC%B4%EB%A6%AC\">마무리</a></p>\n</li>\n</ul>\n</div>","frontmatter":{"date":"June 04, 2023","title":"여러 플랫폼에 대응할 수 있는 OAuth 코드로 개선하기","categories":"Spring","author":"서코코","emoji":"🌱"},"fields":{"slug":"/backend/spring/oauth-refactoring/"}},"site":{"siteMetadata":{"siteUrl":"https://seokho-ham.github.io","comments":{"utterances":{"repo":"seokho-ham/blog-comments"}}}}},"pageContext":{"slug":"/backend/spring/spring-security-and-oauth/","nextSlug":"/backend/database/offset-nooffset/","prevSlug":"/backend/spring/oauth-refactoring/"}},"staticQueryHashes":["1073350324","1956554647","2938748437","3350743975"]}