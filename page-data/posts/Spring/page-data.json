{"componentChunkName":"component---src-templates-category-template-js","path":"/posts/Spring","result":{"pageContext":{"currentCategory":"Spring","categories":["All","Spring","Database","Gradle","회고"],"edges":[{"node":{"id":"7d0c0069-5b0a-5c37-94d4-e78df4a463fe","excerpt":"서론 이전 글에서 SpringSecurity가 OAuth 로그인을 처리하는 과정을 디버깅을 통해 학습했습니다. 학습경험을 바탕으로 식도락 프로젝트의 기존 OAuth 로그인 코드를 개선한 과정에 대해 글을 써보려 합니다. 기존의 문제점 카카오 로그인에 의존적이며 확장에 닫혀있는 코드. 새로운 플랫폼을 지원하도록 확장하기 위해서는 요청을 보내는 클라이언트뿐만 아니라 비즈니스로직이 담긴 서비스 클래스까지 변경이 발생합니다. 또한 추가적으로 작성해야되는 클래스가 너무 많이 필요합니다. Properties 클래스의 주입. 기존의 서비스 코드에서는 카카오api 사용에 필요한 정보를 담은 KakaoProperties 클래스를 직접 주입받아서 사용하고 있었습니다. 즉, 새로운 플랫폼을 지원할때마다 주입받아야하는 클래스가 늘어나야 했으며 요청 형태에 따라 조건문으로 구별해서 사용해야 했습니다.     Response 객체. 응답을 담든 Response 객체가 카카오의 응답형태에 종속적이었습니다.\n…","fields":{"slug":"/backend/spring/oauth-refactoring/"},"frontmatter":{"categories":"Spring","title":"여러 플랫폼에 대응할 수 있는 OAuth 코드로 개선하기","date":"June 04, 2023"}},"next":{"fields":{"slug":"/backend/spring/spring-security-and-oauth/"}},"previous":null},{"node":{"id":"766cc513-3622-5387-a92f-5c9383ec5794","excerpt":"서론 저는 이전에 참여했던 사이드 프로젝트 에서 OAuth 로그인 개발을 담당했습니다. 그리고 이번에 프로젝트 리팩토링을 계획하면서 가장 마음에 안들던 로그인 관련 코드를 개선하기로 결정했습니다. 최초 기획에서는 카카오 로그인만을 사용하기로 했기 때문에 카카오 로그인에 맞게 코드를 작성하였고, 현재 로그인 관련 코드는 카카오 로그인에 종속적인 코드입니다. 때문에 새로운 로그인 방식을 도입하기에도 까다로운 상황이라 이번 기회에 OAuth 로그인 관련 코드를 개선하기로 했습니다. OAuth 관련 클래스들을 추상화하기 위해 고민하던 중 SpringSecurity에서는 어떻게 여러개의 플랫폼에 쉽게 대응할 수 있도록 했는지, 실제 내부 동작은 어떻게 동작하는지 궁금해졌고 그래서 디버깅을 통해 내부 동작을 학습해보았습니다. SpringSecurity? 공식문서에서는 애플리케이션 보안(특히 유저의 인증, 인가)을 관리하기 위해 제공되는 프레임워크라고 설명합니다.\n대표적인 특징으로는 Sprin…","fields":{"slug":"/backend/spring/spring-security-and-oauth/"},"frontmatter":{"categories":"Spring","title":"SpringSecurity가 OAuth 로그인을 처리하는 과정 파헤치기","date":"March 05, 2023"}},"next":{"fields":{"slug":"/backend/database/offset-nooffset/"}},"previous":{"fields":{"slug":"/backend/spring/oauth-refactoring/"}}},{"node":{"id":"3b807c7e-94d4-56bf-a827-5a839084efa3","excerpt":"지난 Feign Client 적용기에 이어서 WireMock을 이용한 테스트 경험을 소개합니다. 해당 글에서 사용하는 wiremock 의존성을 위해서는 spring cloud에 대한 의존성이 필요합니다. 서론 이번 프로젝트에서는 기능 개발 시 인수테스트, 통합테스트, 단위테스트를 먼저 작성하고 개발을 진행하려고 노력하고 있습니다.\n저는 OAuth 로그인 기능을 맡았고 해당 기능에 대한 인수테스트를 작성하는 과정에서 “어떻게하면 외부 api에 대해 실제 상황에 가까운 테스트를 할 수 있을지”에 대해 고민하게 되었습니다. 일반적으로 사용되는 Mockito를 사용하여 테스트를 진행할 수 있었지만 이 방식은 한계가 있다고 느꼈습니다.\n외부 api를 사용할때는 http 요청과 응답, 응답값에 대한 역직렬화 과정 등이 발생하는데 Mockito는 단순히 목객체를 주입받아서 메서드를 호출하는 방식으로 동작하기 때문입니다. 그렇다고 실제 카카오 Api를 호출해서 테스트할수도 없는 노릇이었습니다. …","fields":{"slug":"/backend/spring/wiremock/"},"frontmatter":{"categories":"Spring","title":"테스트에서 Wiremock을 이용해서 외부 의존성 줄이기","date":"August 21, 2022"}},"next":{"fields":{"slug":"/backend/spring/feign_client_적용기/"}},"previous":{"fields":{"slug":"/backend/gradle/gradle 맛보기/"}}},{"node":{"id":"a7653648-1f72-5136-bc7e-b05fbfc24a0e","excerpt":"서론 현재 진행하고 있는 식당 리뷰 sns 프로젝트에서 유저 로그인 기능의 구현을 담당하고 있다. 카카오 로그인을 구현하던 중, 카카오에서 제공하는 api에 Http 요청을 보내기 위해서는 클라이언트 객체를 사용해야했고 흔히 알고 있는 RestTemplate과 WebClient를 후보에 두고 고민하고 있었다.\n그러던 중 쿠킴의 소개로 Feign Client의 존재를 알게 되었다. 💫 Feign Client란? Feign Client란 Netflix에서 개발한 Http Client다. (HttpClient는 Http 요청을 간편하게 만들어서 보낼 수 있도록 돕는 객체라고 생각하면 될것 같다.) 처음에는 Netflix에서 자체적으로 개발을 진행했지만 현재는 오픈소스로 전환했으며 SpringCloud 프레임워크의 프로젝트 중 하나로 들어가있다. 장점 SpringMvc에서 제공되는 어노테이션을 그대로 사용할 수 있다. (Spring Cloud의 starter-openfeign을 사용할 경…","fields":{"slug":"/backend/spring/feign_client_적용기/"},"frontmatter":{"categories":"Spring","title":"프로젝트에 Feign Client를 적용해보자","date":"August 13, 2022"}},"next":{"fields":{"slug":"/review/코드스쿼드 회고/"}},"previous":{"fields":{"slug":"/backend/spring/wiremock/"}}},{"node":{"id":"b53d112e-ac89-5fcd-9b78-e4f25b1f72a8","excerpt":"서론 이번 글은 IssueTracker 프로젝트를 진행하면서 겪었던 영속성 컨텍스트와 관련된 문제를 맞닥트리면서 알게 된 OSIV라는 개념을 정리해보기 위해 작성하게 되었다. 고민 : 미션을 진행하며 대부분의 api에서 유저의 정보가 필요할것이라고 판단했고, 매번 유저를 조회하는 코드의 중복을 제거하고 싶었다. 해결책 : jwt 토큰을 통해 받은 유저의 id를 사용해 인터셉터에서 미리 유저 객체를 조회한 뒤, ArgumentResolver 를 사용해서 해당 유저 객체를 컨트롤러에서 파라미터로 받아서 사용하기로 했다. 하지만 예상하지 못한 문제가 발생했다. 인터셉터에서 조회해서 컨트롤러에서 넘겨받은 유저 객체는 영속성 컨텍스트에서 관리해주지 않았다. 원인은 영속성 컨텍스트가 생성되는 시점이 우리가 등록한 인터셉터가 실행된 이후였기 때문이다. 함께 원인을 찾던 중 영속성 컨텍스트의 생명주기에 대해 서로 다르게 알고 있었는데 토리는 “트랜잭션 단위”, 나는 “요청 단위”로 알고 있었다.…","fields":{"slug":"/backend/spring/osvi/"},"frontmatter":{"categories":"Spring","title":"OSIV란?","date":"June 23, 2022"}},"next":null,"previous":{"fields":{"slug":"/review/코드스쿼드 회고/"}}}]}},"staticQueryHashes":["1073350324","1956554647","2938748437"]}