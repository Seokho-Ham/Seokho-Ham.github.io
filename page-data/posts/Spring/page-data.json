{"componentChunkName":"component---src-templates-category-template-js","path":"/posts/Spring","result":{"pageContext":{"currentCategory":"Spring","categories":["All","Spring"],"edges":[{"node":{"id":"11195f5e-b8eb-5046-95a9-e0edba97c05d","excerpt":"지난 Feign Client 적용기에 이어서 WireMock을 이용한 테스트 경험을 소개합니다. 해당 글에서 사용하는 wiremock 의존성을 위해서는 spring cloud에 대한 의존성이 필요합니다. 서론 이번 프로젝트에서는 기능 개발 시 인수테스트, 통합테스트, 단위테스트를 먼저 작성하고 개발을 진행하려고 노력하고 있습니다.\n저는 OAuth 로그인 기능을 맡았고 해당 기능에 대한  인수테스트를 작성하는 과정에서 “어떻게하면 외부 api에 대해 실제 상황에 가까운 테스트를 할 수 있을지”에 대해 고민하게 되었습니다. 일반적으로 사용되는 Mockito를 사용하여 테스트를 진행할 수 있었지만 이 방식은 한계가 있다고 느꼈습니다.\n외부 api를 사용할때는 http 요청과 응답, 응답값에 대한 역직렬화 과정 등이 발생하는데 Mockito는 단순히 목객체를 주입받아서 메서드를 호출하는 방식으로 동작하기 때문입니다. 그렇다고 실제 카카오 Api를 호출해서 테스트할수도 없는 노릇이었습니다.…","fields":{"slug":"/spring/wiremock/"},"frontmatter":{"categories":"Spring","title":"테스트에서 Wiremock을 이용해서 외부 의존성 줄이기","date":"August 21, 2022"}},"next":{"fields":{"slug":"/spring/feign_client_적용기/"}},"previous":null},{"node":{"id":"69caf21c-6b3e-5355-a016-4a36e66dba44","excerpt":"서론 현재 진행하고 있는 식당 리뷰 sns 프로젝트에서 유저 로그인 기능의 구현을 담당하고 있다. 카카오 로그인을 구현하던 중, 카카오에서 제공하는 api에 Http 요청을 보내기 위해서는 클라이언트 객체를 사용해야했고 흔히 알고 있는 RestTemplate과 WebClient를 후보에 두고 고민하고 있었다.\n그러던 중 쿠킴의 소개로 Feign Client의 존재를 알게 되었다. 💫 Feign Client란? Feign Client란 Netflix에서 개발한 Http Client다. (HttpClient는 Http 요청을 간편하게 만들어서 보낼 수 있도록 돕는 객체라고 생각하면 될것 같다.) 처음에는 Netflix에서 자체적으로 개발을 진행했지만 현재는 오픈소스로 전환했으며 SpringCloud 프레임워크의 프로젝트 중 하나로 들어가있다. 장점 SpringMvc에서 제공되는 어노테이션을 그대로 사용할 수 있다. (Spring Cloud의 starter-openfeign을 사용할 경…","fields":{"slug":"/spring/feign_client_적용기/"},"frontmatter":{"categories":"Spring","title":"프로젝트에 Feign Client를 적용해보자","date":"August 13, 2022"}},"next":{"fields":{"slug":"/spring/osvi/"}},"previous":{"fields":{"slug":"/spring/wiremock/"}}},{"node":{"id":"44f76e18-816a-5e7a-8a6b-b4ebcdcce835","excerpt":"서론 이번 글은 IssueTracker 프로젝트를 진행하면서 겪었던 영속성 컨텍스트와 관련된 문제를 맞닥트리면서 알게 된 OSIV라는 개념을 정리해보기 위해 작성하게 되었다. 고민 : 미션을 진행하며 대부분의 api에서 유저의 정보가 필요할것이라고 판단했고, 매번 유저를 조회하는 코드의 중복을 제거하고 싶었다. 해결책 : jwt 토큰을 통해 받은 유저의 id를 사용해 인터셉터에서 미리 유저 객체를 조회한 뒤, ArgumentResolver 를 사용해서 해당 유저 객체를 컨트롤러에서 파라미터로 받아서 사용하기로 했다. 하지만 예상하지 못한 문제가 발생했다. 인터셉터에서 조회해서 컨트롤러에서 넘겨받은 유저 객체는 영속성 컨텍스트에서 관리해주지 않았다. 원인은 영속성 컨텍스트가 생성되는 시점이 우리가 등록한 인터셉터가 실행된 이후였기 때문이다. 함께 원인을 찾던 중 영속성 컨텍스트의 생명주기에 대해 서로 다르게 알고 있었는데 토리는 “트랜잭션 단위”, 나는 “요청 단위”로 알고 있었다.…","fields":{"slug":"/spring/osvi/"},"frontmatter":{"categories":"Spring","title":"OSIV란?","date":"June 23, 2022"}},"next":null,"previous":{"fields":{"slug":"/spring/feign_client_적용기/"}}}]}},"staticQueryHashes":["1073350324","1956554647","2938748437"]}