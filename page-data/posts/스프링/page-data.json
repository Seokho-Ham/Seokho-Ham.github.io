{
    "componentChunkName": "component---src-templates-category-template-js",
    "path": "/posts/스프링",
    "result": {"pageContext":{"currentCategory":"스프링","categories":["All","자바","회고","스프링","TIL"],"edges":[{"node":{"id":"929e8af9-66b2-5012-8b89-554df0e026d4","excerpt":"서론 이번 글은 IssueTracker 프로젝트를 진행하면서 겪었던 영속성 컨텍스트와 관련된 문제를 맞닥트리면서 알게 된 OSIV라는 개념을 정리해보기 위해 작성하게 되었다. 고민 : 미션을 진행하며 대부분의 api에서 유저의 정보가 필요할것이라고 판단했고, 매번 유저를 조회하는 코드의 중복을 제거하고 싶었다. 해결책 : jwt 토큰을 통해 받은 유저의 id를 사용해 인터셉터에서 미리 유저 객체를 조회한 뒤,  를 사용해서 해당 유저 객체를 컨트롤러에서 파라미터로 받아서 사용하기로 했다. 하지만 예상하지 못한 문제가 발생했다. 인터셉터에서 조회해서 컨트롤러에서 넘겨받은 유저 객체는 영속성 컨텍스트에서 관리해주지 않았다. 원인은 영속성 컨텍스트가 생성되는 시점이 우리가 등록한 인터셉터가 실행된 이후였기 때문이다.\n함께 원인을 찾던 중 영속성 컨텍스트의 생명주기에 대해 서로 다르게 알고 있었는데 토리는 “트랜잭션 단위”, 나는 “요청 단위”로 알고 있었다. (학습해본 결과 둘다 맞는 …","fields":{"slug":"/spring/osiv/"},"frontmatter":{"categories":"스프링","title":"OSIV란?","date":"June 26, 2022"}},"next":{"fields":{"slug":"/til/06/2022-06-23-til/"}},"previous":{"fields":{"slug":"/summary/codesquad/"}}},{"node":{"id":"a69d1e50-e2d3-534a-a0dd-f5e9ba09c3d5","excerpt":"스프링 카페 미션 3단계를 진행하며 Repository에 대한 테스트코드를 작성하며 했던 삽질에 대해 정리한 내용이다. 테스트코드에는 @JdbcTest 어노테이션을 추가했고, 생성자가 하나밖에 없었기 때문에 의존성 주입이 자동으로 이루어질 줄 알았지만 실행해보니 아래와 같은 에러가 발생했다.  처음 보는 에러에 헤매다가 결국 쿠킴의 도움을 받아서 필드에 @Autowired를 붙여주니까 의존성 주입이 되었고 문제는 해결이 됐다.\n하지만 분명 스프링에서는 생성자가 하나면 @Autowired를 생략할 수 있다고 배웠는데 대체 왜 안되는지 이해가 안되서 자료를 찾아보게 되었다. 주입하는 주체가 다르다 SpringApplication의 경우 빈을 주입해주는 역할을 스프링이 담당한다.\n하지만 테스트의 경우 Junit(Jupiter 엔진)에 의해 객체를 주입하게 된다. 이때 JUnit은 ParameterResolver를 사용해서 주입을 한다. Parameter Resolver 테스트에 동적으로…","fields":{"slug":"/spring/why-autowired-is-necessary-in-test/"},"frontmatter":{"categories":"스프링","title":"Test에서는 왜 @Autowired 없이는 의존성 주입이 안될까?","date":"March 18, 2022"}},"next":{"fields":{"slug":"/java/mvc-pattern/"}},"previous":{"fields":{"slug":"/til/03/2022-03-18-til/"}}}]}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}