---
title: '[Javascript] 실행 컨텍스트에 대해 알아보자!'
date: 2021-04-21T11:34:34+09:00
categories: ['Javascript']
tags: ['Javascript', '모던 자바스크립트 DeepDive', '실행 컨텍스트']
draft: false
---



> 아래 내용은 모던 자바스크립트 DeepDive 23장을 학습하며 정리한 내용입니다.

<br>

<!--more-->

## 소스코드부터 알아보자

---

실행 컨텍스트를 알아보기 전에 알아두어야 할 `소스코드`에 대해 먼저 설명하겠다.
`소스코드`란 다른 말로 실행 가능한 코드를 의미한다.
<br><br>
ECMAScript 에서는 소스코드를 4자기 타입으로 구분한다.
<br>
그 이유는 소스코드별로 생성하는 실행 컨텍스트가 다르기 때문이다.
<br>
_(각 소스코드는 코드 내에 정의된 함수, 클래스의 내부 코드는 포함되지 않는다.)_
|소스코드 타입|설명|생성하는 컨텍스트|
|-|-|-|
|전역 코드|전역에 존재하는 코드|전역 실행 컨텍스트|
|함수 코드|함수 내부에 존재하는 코드|함수 실행 컨텍스트|
|eval 코드|eval 함수에 인수로 전달되어 실행되는 코드|eval 실행 컨텍스트|
|모듈 코드|모듈 내부에 존재하는 코드|모듈 실행 컨텍스트|

<br>

모든 소스코드는 2가지 과정을 거친다.
**평가** 와 **실행** 단계다.

<h5 style='color:rgb(15,123,108)'>1. 평가 과정</h5>

- 실행 컨텍스트를 생성한다.
- 변수, 함수 등의 선언문만 먼저 실행한다.
- 생성된 변수나 함수의 식별자를 키로 실행 컨텍스트가 관리하는 스코프에 등록한다.

<h5 style='color:rgb(15,123,108)'>2. 실행 과정</h5>

- 런타임이 시작된다. 선언문을 제외한 소스코드가 실행된다.
- 변수에 할당이 시작되고, 호출되는 함수나 변수는 실행 컨텍스트가 관리하는 스코프에서 검색해서 사용한다.

아래 코드로 예시를 들겠다.

```js
var x;
x = 1;
// 평가 과정 : 변수 x의 선언이 실행된다. 스코프에 x가 저장된다.
// 실행 과정 : 스코프에서 x라는 변수가 있는지 확인한다. 이후, 변수 x에 1이라는 값이 할당된다.
```

<br>

## 실행 컨텍스트? 그게 뭔데?

---

> 소스코드를 실행하는데 필요한 환경을 제공하고 코드의 실행 결과를 실제로 관리하는 영역이다.

<br>
아래 코드를 통해 설명을 이어가겠다.

```js
const x = 1;
const y = 2;

function foo(a) {
  const x = 10;
  const y = 20;

  console.log(a + x + y);
}
foo(100);

console.log(x + y);
```

이 코드의 실행 과정은 어떻게 될까?

<br>

#### 1.이 소스코드는 전역 코드이기 때문에 **전역 실행 컨텍스트**가 생성된다.

#### 2. 평가 단계가 시작된다.

- 변수 x, y와 foo 함수의 선언문이 실행된다.

#### 3. 실행 단계가 시작된다.

- 전역변수 x, y에 값이 할당된다.
- foo함수가 호출된다.

#### 4. 함수가 호출되면 코드의 실행이 중단되고 코드의 실행이 함수의 내부로 이동하게 된다.

#### 5. foo 함수가 실행되며 **함수 실행 컨텍스트**가 생성된다.

#### 6. 마찬가지로 평가 단계가 시작된다.

- 지역변수 x,y, 매개변수 a, arguments 객체가 함수 실행 컨텍스트에 저장된다.
- this의 바인딩이 결정된다. (this 바인딩은 함수 호출 시점에 따라 동적으로 결정되기 때문에)

#### 7. 실행 단계

- x,y,a에 값이 할당되고 console.log 함수가 실행된다.

#### 8. foo함수에는 더이상 실행할 코드가 없기 때문에 전역코드로 돌아가고 남아있는 전역 코드가 실행된다.

<br><br>

## 실행 컨텍스트는 어디서 관리되는걸까?

---

이 흐름을 보다보면 궁금한 점이 하나 생긴다. 코드의 실행 순서가 이동하는데, 이건 어떻게 관리될까?<br>
바로 **실행 컨텍스트 스택**에서 관리된다. 더 익숙한 이름으로는 **Call Stack** 이라고 불린다.

```js
const x = 1;

function foo() {
  const y = 2;
  function bar() {
    const z = 3;
    console.log(x + y + z);
  }
  bar();
}

foo();
```

이 코드를 통하여 CallStack에 실행 컨텍스트들이 관리되는 과정을 알아보자.
<br>
<br>

<br>

#### 1. 전역 실행 컨텍스트가 생성되고 CallStack에 쌓인다.

- 평가와 실행 단계가 진행된다.

#### 2. 실행 단계 중 foo함수가 호출되어 코드의 제어권이 foo 함수 내부로 이동한다.

- 평가와 실행 단계가 진행된다.

#### 3. 실행 단계 중 bar함수가 호출되어 코드의 제어권이 bar 함수 내부로 이동한다.

- 평가와 실행 단계가 진행된다.

#### 4. bar함수가 종료되고 foo함수로 복귀한다.

- bar 함수 실행 컨텍스트는 CallStack에서 제거된다.

#### 5. foo함수가 종료되고 전역코드로, 마지막으로 전역 코드까지 종료된다.

- foo 함수 실행 컨텍스트, 전역 실행 컨텍스트가 순차적으로 CallStack에서 제거된다.

<br><br>

## 실행 컨텍스트 내에서 변수, 함수의 참조는 어떻게 동작하는걸까?

---

여태까지 변수의 참조는 `스코프체인` 이라는 개념으로 인해 가능하다고 알고 있었다. 그럼 이 스코프는 어디에 저장되어있으며 어떻게 연결되어 있을까?
바로 **렉시컬 환경**에 모든 정보가 담겨있다.

<br>

소스코드가 평가되는 시점에 실행 컨텍스트가 생성된다.
동시에 **렉시컬 환경**이 함께 생성되며 실행 컨텍스트에 바인딩된다.

<h4 style='color:rgb(15,123,108)'>렉시컬 환경이란?</h4>

- 식별자와 식별자에 바인딩된 값
- 상위 스코프에 대한 참조

를 기록하는 자료구조다.<br><br>
**렉시컬 환경**는 2가지 컴포넌트로 구성된다.

1. **환경 레코드** : 스코프에 포함된 식별자를 등록하고, 식별자에 바인딩 된 값을 관리하는 저장소다.

2. **외부 렉시컬 환경에 대한 참조** : 상위 스코프를 가리킨다.

이제 코드를 통해 식별자의 참조와 결정이 어떻게 이루어지는지 자세하게 살펴보자.

```js
var x = 1;
const y = 2;

function foo(a) {
  var x = 3;
  const y = 4;

  function bar(b) {
    const z = 5;
    console.log(a + b + x + y + z);
  }
  bar(10);
}

foo(20);
```

### 1. 전역코드의 평가 이전에 전역 객체가 먼저 생성되고 이후 전역 코드의 평가가 이루어진다.

평가 과정에서 **전역 실행 컨텍스트**와 **전역 렉시컬 환경** 이 생성된다.<br>
그리고 전역 렉시컬 환경 내부에는

- 전역 환경 레코드
- 외부 렉시컬 환경에 대한 참조

가 생성된다.

여기서 알아두어야 할것은 전역 환경 레코드 내부는 **2가지 레코드**로 나뉘게 된다.<br>
_(함수 환경 레코드는 이렇게 나누어지지 않는다.)_

- **객체 환경 레코드** : var키워드로 선언된 전역 변수와 함수선언문으로 생성된 전역함수, 빌트인 전역 프로퍼티, 빌트인 전역 함수, 표준 빌트인 객체를 관리한다.
- **선언적 환경 레코드** : let, const 키워드로 선언한 전역 변수를 따로 관리한다.

이것을 이해하면 호이스팅이 발생하는 이유도 이해할 수 있게 된다.
객체 환경 레코드 내에는 맨처음 생성한 전역 객체가 연결된다.

### 1-1. 전역 환경 레코드

- 객체 환경 레코드의 생성 : 변수 x와 foo 함수가 저장된다.
  - var로 선언한 변수는 선언과 초기화가 동시에 발생한다. 즉, 평가 단계부터 이미 undefined 값이 할당되어있는 것이다. <br> **이것이 변수 호이스팅이 발생하는 이유다.**
- 선언적 환경 레코드의 생성 : 변수 y가 저장된다.
  - let, const도 호이스팅이 발생하지만, 초기화 단계는 런타임 시 진행되기 때문에 일시적 사각지대에 빠져 호이스팅이 되지 않는것처럼 작동한다.

### 1-2. 외부 렉시컬 환경에 대한 참조

- 전역코드를 포함하는 소스코드는 없기 때문에 null 값이 할당된다.

### 2. 전역 코드의 실행

- 식별자 결정 작업이 이루어진다.
- 현재 실행중인 실행 컨텍스트를 확인해 참조한다.

### 3. foo 함수 코드 평가

평가 과정을 거치며 함수 실행 컨텍스트와 함수 렉시컬 환경이 생성된다.

### 3-1. 함수 환경 레코드

- 매개변수 a, arguments 객체, 지역변수 x,y, 중첩함수 bar이 저장된다.

### 3-2. 함수 외부 렉시컬 환경에 대한 참조

- 함수에 대한 정의 평가된 시점에 실행중이었던 실행 컨텍스트가 저장된다.<br>
  즉, 전역 실행 컨텍스트가 저장된다.

### 4. 함수 코드 실행

- bar 함수가 실행된다.

### 5. bar 함수 코드의 평가가 이루어지고 foo 함수에서 실행된 작업들이 동일하게 실행된다.

### 6. 코드가 종료되면 순차적으로 CallStack에서 제거된다.

<br>
<br>

##블록 레벨 스코프는 어떻게 동작하는걸까?

---

블록 레벨 스코프의 경우

- 선언적 환경 레코드를 갖는 렉시컬 환경을 새롭게 생성하여 기존의 렉시컬 환경을 대체한다.
- 외부 렉시컬 환경에 대한 참조는 이전의 전역 렉시컬 환경을 가리킨다.

그리고 블록의 코드가 끝나게 되면 다시 이전의 렉시컬 환경을 가리키게 된다.

<br>
<br>

## 마무리

---

처음에는 너무 복잡했지만 이 내용을 알고나니 스코프 체인의 동작원리, 호이스팅의 원리, 클로저의 동작원리들이 더 명확하게 다가오게 된다.<br>
