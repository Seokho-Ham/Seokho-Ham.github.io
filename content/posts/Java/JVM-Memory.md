---
title: "JVM 파헤치기"
date: 2021-12-22T12:27:38+09:00
featuredImage: /images/JVM.jpeg
categories: ['Java']
tags: ['JVM']
draft: false
---

## JVM이란?

JVM은 자바 가상 머신(Java Virtual Machine)으로 자바 프로그램을 동작시키는 역할을 한다. 정확하게는 자바의 바이트코드를 읽고 해석하고 실행하는 역할이다.


<!--more-->

###### JVM이 왜 필요할까?  
개발자가 작성한 소스코드는 컴퓨터가 이해할 수 있는 바이트코드로 변환이 필요하다. 하지만 OS 별로 이해하고 실행시킬 수 있는 코드가 다르기 때문에 OS 별로 다르게 컴파일 해야한다.
JVM을 통해 이런 문제를 해결할 수 있는데, Java는 OS에 상관없이 JVM를 기반으로 동작하도록 설계되었기 때문에 동일한 코드를 가지고 실행할 수 있다.  
(JVM은 OS에 맞는 버전으로 설치해야한다.)

<br>

## JVM의 특징

1. 스택 기반으로 동작한다.
2. 모든 참조형 타입을 심볼릭 레퍼런스를 통해 참조한다.
    - 실제 메모리 주소가 아닌, 참조하는 대상의 이름을 지칭하는 것.
    - 런타임 시 심볼릭 레퍼런스를 실제 메모리 주소로 링킹한다.
3. 가비지 컬렉션이 사용하지 않는 데이터를 제거해줌으로써 메모리 관리를 해준다. 즉, 사용자가 메모리 관리에 거의 신경쓰지 않아도 된다.
4. 기본 자료형을 명확하게 정의해서(플랫폼에 따라 타입의 크기가 변하지 않는다) 호환성이 유지되고, 독립성을 보장한다.
5. 네트워크 바이트 오더 (_정확히 이해를 못했다_)

<br>

## 자바 프로그램 동작 과정
> 1. .java 파일을 .class 파일로 컴파일 한다.  
> (소스코드 -> 자바 바이트코드로 변환하는 과정)
> 2. JVM의 클래스 로더가 바이트코드를 읽어온다.
> 3. 코드가 런타임 데이터 영역에 로딩된다.
> 4. 실행 엔진이 바이트코드를 실행한다.

<img src="/images/JVM-Model.jpg" width="800" height="600">

<br>

## JVM 구조

##### 1. 클래스 로더(Class Loader)
자바는 런타임 시점에 클래스를 로드한다. 이 로드하는 역할을 하는 것이 클래스 로더다.  
jar 파일 내에 저장된 클래스들을 런타임 데이터 영역에 배치한다.

<br>

##### 2. 실행 엔진(Execution Engine)
런타임 데이터 영역에 배치된 바이트 코드를 실행하는 역할을 한다. 명령어 단위로 읽고 실행한다.  
자바 바이트코드는 기계가 완전히 이해할 수 있는 코드는 아니다. 즉, 완전한 기계어로 변환이 필요한데 실행엔진이 이것을 담당한다.

2가지 방식을 사용하는데 아래와 같다.

**1. 인터프리터**
   - 명령어 단위로 읽어서 실행하는 방식이다. 한줄씩 수행하기 때문에 느리다.
   - 한번만 수행되는 코드는 인터프리터 방식으로 하는것이 효율적이다.

**2. JIT 컴파일러**
   - 인터프리터 방식을 사용하다가 적절한 시점에 바이트코드 전체를 컴파일하여 기계어로 변환하고 전체를 실행하는 방식이다.
   - 속도가 훨씬 빠르며, 변환된 기계어는 캐시에 보관되어 재사용 시 더이상 컴파일이 필요하지 않다.

메서드의 사용 빈도수를 기준으로 컴파일 방식이 정해진다.

<br>

##### 3. 런타임 데이터 영역(Runtime Data Area)
프로그램을 수행하기 위해서 OS로부터 할당받은 메모리 공간을 의미한다. 공통으로 사용하는 공간은 3가지영역이 있으며, 나머지 3가지 영역은 각 스레드별로 생성된다.

###### 공통 영역
**1. 힙 영역**
- 인스턴스를 저장하는 영역이다.

**2. 메서드 영역**
- JVM이 시작될 때 생성된다.
- 클래스로더로 읽어온 클래스와 인터페이스의 정보를 가지고 있는 영역이다. 
- 런타임 상수 풀도 이곳에 포함되어 있다

**3. 런타임 상수 풀**  
- 클래스와 인터페이스의 상수뿐만 아니라, 메서드와 필드에 대한 모든 레퍼런스까지 담고 있는 테이블이다.  
- JVM은 런타임 상수 풀을 통해 사용할 메서드나 필드의 실제 주소를 찾아서 참조한다.

<br>

###### 스레드 별 영역
**1. PC 레지스터**  
- 스레드가 시작될 때 생성된다. 어떤 부분을 어떤 명령으로 실행할것인지에 대한 기록을 하는 영역이다.  
- 현재 수행중인 JVM 명령의 주소를 갖는다.

**2. JVM 스택**  

- 임시로 할당되었다가 메소드가 끝나면 소멸되는 데이터를 저장하는 영역이다. 로컬 변수등을 저장하고 있는다.
- **스택 프레임**
  - 하나의 메서드가 실행될 때마다 생성되며, 해당 스레드에 있는 JVM 추가된다. 종료되면 제거된다.
  - 해당 메서드에서 사용되는 지역변수 배열, 실제 메서드의 작업공간인 피연산자 스택이 존재한다.

**3. 네이티브 메서드 스택**
- 바이트코드가 아닌 실제 실행할 수 있는 기계어로 작성된 프로그램을 실행시키는 영역이다. 
- 다른 언어로 작성된 코드를 위한 공간이다.

<br>

### 참고 자료
- [NaverD2 - JVM Internal](https://d2.naver.com/helloworld/1230)  
- [Jbee님의 블로그 - JVM 메모리 구조란?](https://steady-coding.tistory.com/305)