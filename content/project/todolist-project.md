---
emoji: 🤝
title: "[1차 프로젝트] todolist 회고"
date: '2022-05-08 14:55:00'
author: 포키
tags: 코드스쿼드, 프로젝트
categories: 프로젝트
---

> **주제 : Todolist**  
> **기간 : 04.04 ~ 04.15 (2주)**  
> **멤버 : IOS - 데일, 샐리 / BE - 데이브, 포키**  
> **저장소 : [Github 레포](https://github.com/sally4405/todo-list/tree/team-08/be)**

<br>

코드스쿼드에서 진행한 첫번째 그룹 프로젝트는 todolist였다.  

## 작업 내용

---
- Swagger를 사용한 api 문서화
- DB 설계
- 카드에 조회, 등록, 수정, 삭제 기능 구현
- 카드에 대한 작업이 발생할때, 작업에 대한 이벤트를 DB에 등록하는 기능 구현
- aws ec2 서버에 배포

## 문제 및 고민

---

### 1. Controller에서 요청에 body로 넘어온 값을 `@RequestBody`를 사용해 Dto객체로 매핑하는 과정에서 기본 생성자가 없으면 매핑이 되지 않았다.

문제를 해결하기 위해 검색을 하던 중 ObjectMapper가 **기본 생성자를 통해 객체를 생성**하고 **getter 혹은 setter를 사용해 프로퍼티명들을 읽어와서 객체에 값을 설정**해준다는 사실을 알게 되었다.  
하지만 이전에 했던 프로젝트에서는 Dto에 기본 생성자 대신 파라미터를 갖는 생성자가 있으면 문제 없이 생성이 됐었기에 다른 원인이 있다고 생각되었고 리뷰어와 이 문제에 대해 이야기를 나누었다.

이 과정을 통해 `@RequestBody`가 어떤식으로 동작하는지에 대해 조금이나마 파볼 수 있었다.

> 1. `@RequestBody`를 처리하는 `RequestResponseBodyMethodProcessor`에서 `readWithMessageConverters()` 메서드를 호출한다.
> 2. 등록되어 있는 컨버터들을 순회하면서 body의 content-type을 처리할 수 있는 컨버터를 찾아낸다.
> 3. json타입의 경우 `MappingJackson2HttpMessageConverter`가 처리해준다.
> 4. 내부에서는 Jackson 라이브러리에서 제공하는 `ObjectMapper`를 사용해서 객체에 매핑해준다.
>    - 이때 내부에 기본 생성자가 있으면 기본 생성자를 사용해 매핑할 객체를 생성한다.
>    - `@JsonProperty`, `@JsonAutoDetect` 등 Property 관련 어노테이션들이 적용된 Property 기반 클래스면 Property를 기반으로 객체를 생성한다.
>    - 다른 생성자가 존재하면 해당 생성자를 사용해서 객체를 생성한다.
>    - getter, setter를 통해 프로퍼티 명을 읽어온 뒤, 겂을 할당한다.

동작 원리에 대해서는 알게 되었지만, 문제 자체는 해결되지 않았고 리뷰어와 데이브의 로컬에서는 정상적으로 기본생성자 없이도 동작한다는것을 알게되어서 로컬의 프로젝트를 날리고 다시 클론 받아왔다.


### 2. 사용자에게 응답값으로 Dto대신 도메인 객체를 넘겨도 되는가?

처음에는 카드를 조회하는 api에서 카드 도메인 객체를 List에 담아서 그대로 클라이언트에게 응답값으로 전달하도록 했다.
하지만 학습을 하던 중 도메인 객체 대신 Dto 객체를 반환하는것이 좋다는 글을 보게 되었고 이유는 아래와 같았다.

> - Dto 객체는 기본적으로 변경이 자주 발생하는대 Dto 대신 도메인 객체를 사용하면 **Api가 변경될때마다 도메인 객체가 직접적으로 영향을 받게된다**.
> - 클라이언트에게 필요없는 정보까지 전달하게 된다. 즉, **자원의 낭비가 발생한다**.
> - 추가적으로 필요한 값을 세팅해서 전달하려면 `setter` 메서드를 작성해야하고, 계층간 전달되는 과정에서 개발자의 실수로 의도하지 않은 변경이 발생할 수 있다.
> - 사용자에게 DB의 테이블 구조가 그대로 드러난다.

그래서 모든 도메인 객체들을 Dto 객체로 변환해서 반환하도록 코드를 수정했는데 이 과정에서 추가적인 고민이 생겼다.  
**"카드 데이터의 수가 무수히 많다면, 모두 Dto로 변환하는 과정에서 생기는 오버헤드를 감수해야할까?"**

리뷰어에게 해당 내용을 질문했고, 아래와 같은 답변을 받았다.
> **도메인 객체를 새로운 DTO 데이터 클래스로 매핑하는 과정은 당연히 오버헤드가 있을 것입니다. 우리 프로젝트에서야 규모가 작으니까 체감이 안 되겠지만요. 그렇다면 고민해야 할 지점은 성능을 어느 정도 포기하고서라도 DTO 객체를 만들어야 하는 이유를 충분히 공감하고 설득할 수 있어야 한다는 것입니다.**

이 과정을 통해 **다른 사람들이 좋다고 말하는 것들을 그냥 적용하는게 아닌, 현재의 프로젝트와 상황을 고려하여 타당한 근거를 생각해봐야한다는 것**을 다시한번 느꼈다. 

<br>

> **[리뷰 정리 목록](https://kale02.notion.site/1fbca5416db045718808aa645f0e164e)**

## 느낀점

---

처음에는 걱정이 많았지만 좋은 ios 멤버들과, 페어를 만났고 좋은 리뷰어까지 배정되어서 즐겁게 진행했다. 코드 리뷰를 통해 앞으로 학습할 키워드들을 알게 되었고, 얕게 알고 있던 지식들에 깊이를 더할 수 있었던 시간이었다.
특히 좋았던 점은 **단순히 구현을 완료하는것에 목적을 두는게 아닌, 부족한 부분들을 발견하고 채워나가는 시간으로 보낼 수 있었던 점인것 같다.** 앞으로 남은 프로젝트들도 많은 학습을 할 수 있는 시간들로 보낼 수 있으면 좋겠다.
